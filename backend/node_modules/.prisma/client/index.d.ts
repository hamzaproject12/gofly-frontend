
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Agent
 * 
 */
export type Agent = $Result.DefaultSelection<Prisma.$AgentPayload>
/**
 * Model Program
 * 
 */
export type Program = $Result.DefaultSelection<Prisma.$ProgramPayload>
/**
 * Model Hotel
 * 
 */
export type Hotel = $Result.DefaultSelection<Prisma.$HotelPayload>
/**
 * Model ProgramHotelMadina
 * 
 */
export type ProgramHotelMadina = $Result.DefaultSelection<Prisma.$ProgramHotelMadinaPayload>
/**
 * Model ProgramHotelMakkah
 * 
 */
export type ProgramHotelMakkah = $Result.DefaultSelection<Prisma.$ProgramHotelMakkahPayload>
/**
 * Model Room
 * 
 */
export type Room = $Result.DefaultSelection<Prisma.$RoomPayload>
/**
 * Model Reservation
 * 
 */
export type Reservation = $Result.DefaultSelection<Prisma.$ReservationPayload>
/**
 * Model Fichier
 * 
 */
export type Fichier = $Result.DefaultSelection<Prisma.$FichierPayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Expense
 * 
 */
export type Expense = $Result.DefaultSelection<Prisma.$ExpensePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  USER: 'USER',
  ADMIN: 'ADMIN'
};

export type Role = (typeof Role)[keyof typeof Role]


export const City: {
  Madina: 'Madina',
  Makkah: 'Makkah'
};

export type City = (typeof City)[keyof typeof City]


export const RoomType: {
  SINGLE: 'SINGLE',
  DOUBLE: 'DOUBLE',
  TRIPLE: 'TRIPLE',
  QUAD: 'QUAD',
  QUINT: 'QUINT'
};

export type RoomType = (typeof RoomType)[keyof typeof RoomType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type City = $Enums.City

export const City: typeof $Enums.City

export type RoomType = $Enums.RoomType

export const RoomType: typeof $Enums.RoomType

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.agent`: Exposes CRUD operations for the **Agent** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Agents
    * const agents = await prisma.agent.findMany()
    * ```
    */
  get agent(): Prisma.AgentDelegate<ExtArgs>;

  /**
   * `prisma.program`: Exposes CRUD operations for the **Program** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Programs
    * const programs = await prisma.program.findMany()
    * ```
    */
  get program(): Prisma.ProgramDelegate<ExtArgs>;

  /**
   * `prisma.hotel`: Exposes CRUD operations for the **Hotel** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Hotels
    * const hotels = await prisma.hotel.findMany()
    * ```
    */
  get hotel(): Prisma.HotelDelegate<ExtArgs>;

  /**
   * `prisma.programHotelMadina`: Exposes CRUD operations for the **ProgramHotelMadina** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramHotelMadinas
    * const programHotelMadinas = await prisma.programHotelMadina.findMany()
    * ```
    */
  get programHotelMadina(): Prisma.ProgramHotelMadinaDelegate<ExtArgs>;

  /**
   * `prisma.programHotelMakkah`: Exposes CRUD operations for the **ProgramHotelMakkah** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProgramHotelMakkahs
    * const programHotelMakkahs = await prisma.programHotelMakkah.findMany()
    * ```
    */
  get programHotelMakkah(): Prisma.ProgramHotelMakkahDelegate<ExtArgs>;

  /**
   * `prisma.room`: Exposes CRUD operations for the **Room** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Rooms
    * const rooms = await prisma.room.findMany()
    * ```
    */
  get room(): Prisma.RoomDelegate<ExtArgs>;

  /**
   * `prisma.reservation`: Exposes CRUD operations for the **Reservation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reservations
    * const reservations = await prisma.reservation.findMany()
    * ```
    */
  get reservation(): Prisma.ReservationDelegate<ExtArgs>;

  /**
   * `prisma.fichier`: Exposes CRUD operations for the **Fichier** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Fichiers
    * const fichiers = await prisma.fichier.findMany()
    * ```
    */
  get fichier(): Prisma.FichierDelegate<ExtArgs>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs>;

  /**
   * `prisma.expense`: Exposes CRUD operations for the **Expense** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Expenses
    * const expenses = await prisma.expense.findMany()
    * ```
    */
  get expense(): Prisma.ExpenseDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Agent: 'Agent',
    Program: 'Program',
    Hotel: 'Hotel',
    ProgramHotelMadina: 'ProgramHotelMadina',
    ProgramHotelMakkah: 'ProgramHotelMakkah',
    Room: 'Room',
    Reservation: 'Reservation',
    Fichier: 'Fichier',
    Payment: 'Payment',
    Expense: 'Expense'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "agent" | "program" | "hotel" | "programHotelMadina" | "programHotelMakkah" | "room" | "reservation" | "fichier" | "payment" | "expense"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Agent: {
        payload: Prisma.$AgentPayload<ExtArgs>
        fields: Prisma.AgentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AgentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AgentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findFirst: {
            args: Prisma.AgentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AgentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          findMany: {
            args: Prisma.AgentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          create: {
            args: Prisma.AgentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          createMany: {
            args: Prisma.AgentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AgentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>[]
          }
          delete: {
            args: Prisma.AgentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          update: {
            args: Prisma.AgentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          deleteMany: {
            args: Prisma.AgentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AgentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AgentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AgentPayload>
          }
          aggregate: {
            args: Prisma.AgentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAgent>
          }
          groupBy: {
            args: Prisma.AgentGroupByArgs<ExtArgs>
            result: $Utils.Optional<AgentGroupByOutputType>[]
          }
          count: {
            args: Prisma.AgentCountArgs<ExtArgs>
            result: $Utils.Optional<AgentCountAggregateOutputType> | number
          }
        }
      }
      Program: {
        payload: Prisma.$ProgramPayload<ExtArgs>
        fields: Prisma.ProgramFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findFirst: {
            args: Prisma.ProgramFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          findMany: {
            args: Prisma.ProgramFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          create: {
            args: Prisma.ProgramCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          createMany: {
            args: Prisma.ProgramCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>[]
          }
          delete: {
            args: Prisma.ProgramDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          update: {
            args: Prisma.ProgramUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          deleteMany: {
            args: Prisma.ProgramDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramPayload>
          }
          aggregate: {
            args: Prisma.ProgramAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgram>
          }
          groupBy: {
            args: Prisma.ProgramGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramCountAggregateOutputType> | number
          }
        }
      }
      Hotel: {
        payload: Prisma.$HotelPayload<ExtArgs>
        fields: Prisma.HotelFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HotelFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HotelFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findFirst: {
            args: Prisma.HotelFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HotelFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          findMany: {
            args: Prisma.HotelFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          create: {
            args: Prisma.HotelCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          createMany: {
            args: Prisma.HotelCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HotelCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>[]
          }
          delete: {
            args: Prisma.HotelDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          update: {
            args: Prisma.HotelUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          deleteMany: {
            args: Prisma.HotelDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HotelUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HotelUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HotelPayload>
          }
          aggregate: {
            args: Prisma.HotelAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHotel>
          }
          groupBy: {
            args: Prisma.HotelGroupByArgs<ExtArgs>
            result: $Utils.Optional<HotelGroupByOutputType>[]
          }
          count: {
            args: Prisma.HotelCountArgs<ExtArgs>
            result: $Utils.Optional<HotelCountAggregateOutputType> | number
          }
        }
      }
      ProgramHotelMadina: {
        payload: Prisma.$ProgramHotelMadinaPayload<ExtArgs>
        fields: Prisma.ProgramHotelMadinaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramHotelMadinaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramHotelMadinaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload>
          }
          findFirst: {
            args: Prisma.ProgramHotelMadinaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramHotelMadinaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload>
          }
          findMany: {
            args: Prisma.ProgramHotelMadinaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload>[]
          }
          create: {
            args: Prisma.ProgramHotelMadinaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload>
          }
          createMany: {
            args: Prisma.ProgramHotelMadinaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramHotelMadinaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload>[]
          }
          delete: {
            args: Prisma.ProgramHotelMadinaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload>
          }
          update: {
            args: Prisma.ProgramHotelMadinaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload>
          }
          deleteMany: {
            args: Prisma.ProgramHotelMadinaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramHotelMadinaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramHotelMadinaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMadinaPayload>
          }
          aggregate: {
            args: Prisma.ProgramHotelMadinaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramHotelMadina>
          }
          groupBy: {
            args: Prisma.ProgramHotelMadinaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramHotelMadinaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramHotelMadinaCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramHotelMadinaCountAggregateOutputType> | number
          }
        }
      }
      ProgramHotelMakkah: {
        payload: Prisma.$ProgramHotelMakkahPayload<ExtArgs>
        fields: Prisma.ProgramHotelMakkahFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProgramHotelMakkahFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProgramHotelMakkahFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload>
          }
          findFirst: {
            args: Prisma.ProgramHotelMakkahFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProgramHotelMakkahFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload>
          }
          findMany: {
            args: Prisma.ProgramHotelMakkahFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload>[]
          }
          create: {
            args: Prisma.ProgramHotelMakkahCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload>
          }
          createMany: {
            args: Prisma.ProgramHotelMakkahCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProgramHotelMakkahCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload>[]
          }
          delete: {
            args: Prisma.ProgramHotelMakkahDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload>
          }
          update: {
            args: Prisma.ProgramHotelMakkahUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload>
          }
          deleteMany: {
            args: Prisma.ProgramHotelMakkahDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProgramHotelMakkahUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProgramHotelMakkahUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProgramHotelMakkahPayload>
          }
          aggregate: {
            args: Prisma.ProgramHotelMakkahAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProgramHotelMakkah>
          }
          groupBy: {
            args: Prisma.ProgramHotelMakkahGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProgramHotelMakkahGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProgramHotelMakkahCountArgs<ExtArgs>
            result: $Utils.Optional<ProgramHotelMakkahCountAggregateOutputType> | number
          }
        }
      }
      Room: {
        payload: Prisma.$RoomPayload<ExtArgs>
        fields: Prisma.RoomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findFirst: {
            args: Prisma.RoomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          findMany: {
            args: Prisma.RoomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          create: {
            args: Prisma.RoomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          createMany: {
            args: Prisma.RoomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RoomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>[]
          }
          delete: {
            args: Prisma.RoomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          update: {
            args: Prisma.RoomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          deleteMany: {
            args: Prisma.RoomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoomPayload>
          }
          aggregate: {
            args: Prisma.RoomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoom>
          }
          groupBy: {
            args: Prisma.RoomGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoomGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoomCountArgs<ExtArgs>
            result: $Utils.Optional<RoomCountAggregateOutputType> | number
          }
        }
      }
      Reservation: {
        payload: Prisma.$ReservationPayload<ExtArgs>
        fields: Prisma.ReservationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ReservationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ReservationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findFirst: {
            args: Prisma.ReservationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ReservationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          findMany: {
            args: Prisma.ReservationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          create: {
            args: Prisma.ReservationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          createMany: {
            args: Prisma.ReservationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ReservationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>[]
          }
          delete: {
            args: Prisma.ReservationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          update: {
            args: Prisma.ReservationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          deleteMany: {
            args: Prisma.ReservationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ReservationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ReservationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ReservationPayload>
          }
          aggregate: {
            args: Prisma.ReservationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateReservation>
          }
          groupBy: {
            args: Prisma.ReservationGroupByArgs<ExtArgs>
            result: $Utils.Optional<ReservationGroupByOutputType>[]
          }
          count: {
            args: Prisma.ReservationCountArgs<ExtArgs>
            result: $Utils.Optional<ReservationCountAggregateOutputType> | number
          }
        }
      }
      Fichier: {
        payload: Prisma.$FichierPayload<ExtArgs>
        fields: Prisma.FichierFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FichierFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FichierFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload>
          }
          findFirst: {
            args: Prisma.FichierFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FichierFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload>
          }
          findMany: {
            args: Prisma.FichierFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload>[]
          }
          create: {
            args: Prisma.FichierCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload>
          }
          createMany: {
            args: Prisma.FichierCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FichierCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload>[]
          }
          delete: {
            args: Prisma.FichierDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload>
          }
          update: {
            args: Prisma.FichierUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload>
          }
          deleteMany: {
            args: Prisma.FichierDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FichierUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.FichierUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FichierPayload>
          }
          aggregate: {
            args: Prisma.FichierAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFichier>
          }
          groupBy: {
            args: Prisma.FichierGroupByArgs<ExtArgs>
            result: $Utils.Optional<FichierGroupByOutputType>[]
          }
          count: {
            args: Prisma.FichierCountArgs<ExtArgs>
            result: $Utils.Optional<FichierCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Expense: {
        payload: Prisma.$ExpensePayload<ExtArgs>
        fields: Prisma.ExpenseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ExpenseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ExpenseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findFirst: {
            args: Prisma.ExpenseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ExpenseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          findMany: {
            args: Prisma.ExpenseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          create: {
            args: Prisma.ExpenseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          createMany: {
            args: Prisma.ExpenseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ExpenseCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>[]
          }
          delete: {
            args: Prisma.ExpenseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          update: {
            args: Prisma.ExpenseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          deleteMany: {
            args: Prisma.ExpenseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ExpenseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ExpenseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ExpensePayload>
          }
          aggregate: {
            args: Prisma.ExpenseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateExpense>
          }
          groupBy: {
            args: Prisma.ExpenseGroupByArgs<ExtArgs>
            result: $Utils.Optional<ExpenseGroupByOutputType>[]
          }
          count: {
            args: Prisma.ExpenseCountArgs<ExtArgs>
            result: $Utils.Optional<ExpenseCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type AgentCountOutputType
   */

  export type AgentCountOutputType = {
    reservations: number
    payments: number
  }

  export type AgentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | AgentCountOutputTypeCountReservationsArgs
    payments?: boolean | AgentCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AgentCountOutputType
     */
    select?: AgentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }

  /**
   * AgentCountOutputType without action
   */
  export type AgentCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type ProgramCountOutputType
   */

  export type ProgramCountOutputType = {
    expenses: number
    hotelsMadina: number
    hotelsMakkah: number
    rooms: number
    reservations: number
  }

  export type ProgramCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | ProgramCountOutputTypeCountExpensesArgs
    hotelsMadina?: boolean | ProgramCountOutputTypeCountHotelsMadinaArgs
    hotelsMakkah?: boolean | ProgramCountOutputTypeCountHotelsMakkahArgs
    rooms?: boolean | ProgramCountOutputTypeCountRoomsArgs
    reservations?: boolean | ProgramCountOutputTypeCountReservationsArgs
  }

  // Custom InputTypes
  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramCountOutputType
     */
    select?: ProgramCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountHotelsMadinaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramHotelMadinaWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountHotelsMakkahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramHotelMakkahWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }

  /**
   * ProgramCountOutputType without action
   */
  export type ProgramCountOutputTypeCountReservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
  }


  /**
   * Count Type HotelCountOutputType
   */

  export type HotelCountOutputType = {
    programsMadina: number
    programsMakkah: number
    rooms: number
  }

  export type HotelCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programsMadina?: boolean | HotelCountOutputTypeCountProgramsMadinaArgs
    programsMakkah?: boolean | HotelCountOutputTypeCountProgramsMakkahArgs
    rooms?: boolean | HotelCountOutputTypeCountRoomsArgs
  }

  // Custom InputTypes
  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HotelCountOutputType
     */
    select?: HotelCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountProgramsMadinaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramHotelMadinaWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountProgramsMakkahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramHotelMakkahWhereInput
  }

  /**
   * HotelCountOutputType without action
   */
  export type HotelCountOutputTypeCountRoomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
  }


  /**
   * Count Type ReservationCountOutputType
   */

  export type ReservationCountOutputType = {
    documents: number
    payments: number
    expenses: number
  }

  export type ReservationCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | ReservationCountOutputTypeCountDocumentsArgs
    payments?: boolean | ReservationCountOutputTypeCountPaymentsArgs
    expenses?: boolean | ReservationCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ReservationCountOutputType
     */
    select?: ReservationCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountDocumentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FichierWhereInput
  }

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * ReservationCountOutputType without action
   */
  export type ReservationCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Count Type FichierCountOutputType
   */

  export type FichierCountOutputType = {
    expenses: number
  }

  export type FichierCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | FichierCountOutputTypeCountExpensesArgs
  }

  // Custom InputTypes
  /**
   * FichierCountOutputType without action
   */
  export type FichierCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FichierCountOutputType
     */
    select?: FichierCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FichierCountOutputType without action
   */
  export type FichierCountOutputTypeCountExpensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    id: number | null
  }

  export type UserSumAggregateOutputType = {
    id: number | null
  }

  export type UserMinAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: number | null
    email: string | null
    password: string | null
    name: string | null
    role: $Enums.Role | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    name: number
    role: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    id?: true
  }

  export type UserSumAggregateInputType = {
    id?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    name?: true
    role?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: number
    email: string
    password: string
    name: string
    role: $Enums.Role
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    name?: boolean
    role?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      email: string
      password: string
      name: string
      role: $Enums.Role
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'Int'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'Role'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Model Agent
   */

  export type AggregateAgent = {
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  export type AgentAvgAggregateOutputType = {
    id: number | null
  }

  export type AgentSumAggregateOutputType = {
    id: number | null
  }

  export type AgentMinAggregateOutputType = {
    id: number | null
    nom: string | null
    email: string | null
    motDePasse: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentMaxAggregateOutputType = {
    id: number | null
    nom: string | null
    email: string | null
    motDePasse: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type AgentCountAggregateOutputType = {
    id: number
    nom: number
    email: number
    motDePasse: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type AgentAvgAggregateInputType = {
    id?: true
  }

  export type AgentSumAggregateInputType = {
    id?: true
  }

  export type AgentMinAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    motDePasse?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentMaxAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    motDePasse?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type AgentCountAggregateInputType = {
    id?: true
    nom?: true
    email?: true
    motDePasse?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type AgentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agent to aggregate.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Agents
    **/
    _count?: true | AgentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AgentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AgentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AgentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AgentMaxAggregateInputType
  }

  export type GetAgentAggregateType<T extends AgentAggregateArgs> = {
        [P in keyof T & keyof AggregateAgent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAgent[P]>
      : GetScalarType<T[P], AggregateAgent[P]>
  }




  export type AgentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AgentWhereInput
    orderBy?: AgentOrderByWithAggregationInput | AgentOrderByWithAggregationInput[]
    by: AgentScalarFieldEnum[] | AgentScalarFieldEnum
    having?: AgentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AgentCountAggregateInputType | true
    _avg?: AgentAvgAggregateInputType
    _sum?: AgentSumAggregateInputType
    _min?: AgentMinAggregateInputType
    _max?: AgentMaxAggregateInputType
  }

  export type AgentGroupByOutputType = {
    id: number
    nom: string
    email: string | null
    motDePasse: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: AgentCountAggregateOutputType | null
    _avg: AgentAvgAggregateOutputType | null
    _sum: AgentSumAggregateOutputType | null
    _min: AgentMinAggregateOutputType | null
    _max: AgentMaxAggregateOutputType | null
  }

  type GetAgentGroupByPayload<T extends AgentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AgentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AgentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AgentGroupByOutputType[P]>
            : GetScalarType<T[P], AgentGroupByOutputType[P]>
        }
      >
    >


  export type AgentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    motDePasse?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    reservations?: boolean | Agent$reservationsArgs<ExtArgs>
    payments?: boolean | Agent$paymentsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nom?: boolean
    email?: boolean
    motDePasse?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["agent"]>

  export type AgentSelectScalar = {
    id?: boolean
    nom?: boolean
    email?: boolean
    motDePasse?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type AgentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservations?: boolean | Agent$reservationsArgs<ExtArgs>
    payments?: boolean | Agent$paymentsArgs<ExtArgs>
    _count?: boolean | AgentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type AgentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $AgentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Agent"
    objects: {
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      nom: string
      email: string | null
      motDePasse: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["agent"]>
    composites: {}
  }

  type AgentGetPayload<S extends boolean | null | undefined | AgentDefaultArgs> = $Result.GetResult<Prisma.$AgentPayload, S>

  type AgentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AgentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AgentCountAggregateInputType | true
    }

  export interface AgentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Agent'], meta: { name: 'Agent' } }
    /**
     * Find zero or one Agent that matches the filter.
     * @param {AgentFindUniqueArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AgentFindUniqueArgs>(args: SelectSubset<T, AgentFindUniqueArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Agent that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AgentFindUniqueOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AgentFindUniqueOrThrowArgs>(args: SelectSubset<T, AgentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Agent that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AgentFindFirstArgs>(args?: SelectSubset<T, AgentFindFirstArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Agent that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindFirstOrThrowArgs} args - Arguments to find a Agent
     * @example
     * // Get one Agent
     * const agent = await prisma.agent.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AgentFindFirstOrThrowArgs>(args?: SelectSubset<T, AgentFindFirstOrThrowArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Agents that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Agents
     * const agents = await prisma.agent.findMany()
     * 
     * // Get first 10 Agents
     * const agents = await prisma.agent.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const agentWithIdOnly = await prisma.agent.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AgentFindManyArgs>(args?: SelectSubset<T, AgentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Agent.
     * @param {AgentCreateArgs} args - Arguments to create a Agent.
     * @example
     * // Create one Agent
     * const Agent = await prisma.agent.create({
     *   data: {
     *     // ... data to create a Agent
     *   }
     * })
     * 
     */
    create<T extends AgentCreateArgs>(args: SelectSubset<T, AgentCreateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Agents.
     * @param {AgentCreateManyArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AgentCreateManyArgs>(args?: SelectSubset<T, AgentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Agents and returns the data saved in the database.
     * @param {AgentCreateManyAndReturnArgs} args - Arguments to create many Agents.
     * @example
     * // Create many Agents
     * const agent = await prisma.agent.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Agents and only return the `id`
     * const agentWithIdOnly = await prisma.agent.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AgentCreateManyAndReturnArgs>(args?: SelectSubset<T, AgentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Agent.
     * @param {AgentDeleteArgs} args - Arguments to delete one Agent.
     * @example
     * // Delete one Agent
     * const Agent = await prisma.agent.delete({
     *   where: {
     *     // ... filter to delete one Agent
     *   }
     * })
     * 
     */
    delete<T extends AgentDeleteArgs>(args: SelectSubset<T, AgentDeleteArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Agent.
     * @param {AgentUpdateArgs} args - Arguments to update one Agent.
     * @example
     * // Update one Agent
     * const agent = await prisma.agent.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AgentUpdateArgs>(args: SelectSubset<T, AgentUpdateArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Agents.
     * @param {AgentDeleteManyArgs} args - Arguments to filter Agents to delete.
     * @example
     * // Delete a few Agents
     * const { count } = await prisma.agent.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AgentDeleteManyArgs>(args?: SelectSubset<T, AgentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Agents
     * const agent = await prisma.agent.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AgentUpdateManyArgs>(args: SelectSubset<T, AgentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Agent.
     * @param {AgentUpsertArgs} args - Arguments to update or create a Agent.
     * @example
     * // Update or create a Agent
     * const agent = await prisma.agent.upsert({
     *   create: {
     *     // ... data to create a Agent
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Agent we want to update
     *   }
     * })
     */
    upsert<T extends AgentUpsertArgs>(args: SelectSubset<T, AgentUpsertArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Agents.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentCountArgs} args - Arguments to filter Agents to count.
     * @example
     * // Count the number of Agents
     * const count = await prisma.agent.count({
     *   where: {
     *     // ... the filter for the Agents we want to count
     *   }
     * })
    **/
    count<T extends AgentCountArgs>(
      args?: Subset<T, AgentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AgentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AgentAggregateArgs>(args: Subset<T, AgentAggregateArgs>): Prisma.PrismaPromise<GetAgentAggregateType<T>>

    /**
     * Group by Agent.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AgentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AgentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AgentGroupByArgs['orderBy'] }
        : { orderBy?: AgentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AgentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAgentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Agent model
   */
  readonly fields: AgentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Agent.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AgentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservations<T extends Agent$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Agent$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Agent$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Agent model
   */ 
  interface AgentFieldRefs {
    readonly id: FieldRef<"Agent", 'Int'>
    readonly nom: FieldRef<"Agent", 'String'>
    readonly email: FieldRef<"Agent", 'String'>
    readonly motDePasse: FieldRef<"Agent", 'String'>
    readonly isActive: FieldRef<"Agent", 'Boolean'>
    readonly createdAt: FieldRef<"Agent", 'DateTime'>
    readonly updatedAt: FieldRef<"Agent", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Agent findUnique
   */
  export type AgentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findUniqueOrThrow
   */
  export type AgentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent findFirst
   */
  export type AgentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findFirstOrThrow
   */
  export type AgentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agent to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Agents.
     */
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent findMany
   */
  export type AgentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter, which Agents to fetch.
     */
    where?: AgentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Agents to fetch.
     */
    orderBy?: AgentOrderByWithRelationInput | AgentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Agents.
     */
    cursor?: AgentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Agents from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Agents.
     */
    skip?: number
    distinct?: AgentScalarFieldEnum | AgentScalarFieldEnum[]
  }

  /**
   * Agent create
   */
  export type AgentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to create a Agent.
     */
    data: XOR<AgentCreateInput, AgentUncheckedCreateInput>
  }

  /**
   * Agent createMany
   */
  export type AgentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent createManyAndReturn
   */
  export type AgentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Agents.
     */
    data: AgentCreateManyInput | AgentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Agent update
   */
  export type AgentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The data needed to update a Agent.
     */
    data: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
    /**
     * Choose, which Agent to update.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent updateMany
   */
  export type AgentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Agents.
     */
    data: XOR<AgentUpdateManyMutationInput, AgentUncheckedUpdateManyInput>
    /**
     * Filter which Agents to update
     */
    where?: AgentWhereInput
  }

  /**
   * Agent upsert
   */
  export type AgentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * The filter to search for the Agent to update in case it exists.
     */
    where: AgentWhereUniqueInput
    /**
     * In case the Agent found by the `where` argument doesn't exist, create a new Agent with this data.
     */
    create: XOR<AgentCreateInput, AgentUncheckedCreateInput>
    /**
     * In case the Agent was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AgentUpdateInput, AgentUncheckedUpdateInput>
  }

  /**
   * Agent delete
   */
  export type AgentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    /**
     * Filter which Agent to delete.
     */
    where: AgentWhereUniqueInput
  }

  /**
   * Agent deleteMany
   */
  export type AgentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Agents to delete
     */
    where?: AgentWhereInput
  }

  /**
   * Agent.reservations
   */
  export type Agent$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Agent.payments
   */
  export type Agent$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Agent without action
   */
  export type AgentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
  }


  /**
   * Model Program
   */

  export type AggregateProgram = {
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  export type ProgramAvgAggregateOutputType = {
    id: number | null
    nbJoursMadina: number | null
    nbJoursMakkah: number | null
    exchange: number | null
    prixAvionDH: number | null
    prixVisaRiyal: number | null
    profit: number | null
  }

  export type ProgramSumAggregateOutputType = {
    id: number | null
    nbJoursMadina: number | null
    nbJoursMakkah: number | null
    exchange: number | null
    prixAvionDH: number | null
    prixVisaRiyal: number | null
    profit: number | null
  }

  export type ProgramMinAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    visaDeadline: Date | null
    hotelDeadline: Date | null
    flightDeadline: Date | null
    passportDeadline: Date | null
    nbJoursMadina: number | null
    nbJoursMakkah: number | null
    exchange: number | null
    prixAvionDH: number | null
    prixVisaRiyal: number | null
    profit: number | null
  }

  export type ProgramMaxAggregateOutputType = {
    id: number | null
    name: string | null
    created_at: Date | null
    visaDeadline: Date | null
    hotelDeadline: Date | null
    flightDeadline: Date | null
    passportDeadline: Date | null
    nbJoursMadina: number | null
    nbJoursMakkah: number | null
    exchange: number | null
    prixAvionDH: number | null
    prixVisaRiyal: number | null
    profit: number | null
  }

  export type ProgramCountAggregateOutputType = {
    id: number
    name: number
    created_at: number
    visaDeadline: number
    hotelDeadline: number
    flightDeadline: number
    passportDeadline: number
    nbJoursMadina: number
    nbJoursMakkah: number
    exchange: number
    prixAvionDH: number
    prixVisaRiyal: number
    profit: number
    _all: number
  }


  export type ProgramAvgAggregateInputType = {
    id?: true
    nbJoursMadina?: true
    nbJoursMakkah?: true
    exchange?: true
    prixAvionDH?: true
    prixVisaRiyal?: true
    profit?: true
  }

  export type ProgramSumAggregateInputType = {
    id?: true
    nbJoursMadina?: true
    nbJoursMakkah?: true
    exchange?: true
    prixAvionDH?: true
    prixVisaRiyal?: true
    profit?: true
  }

  export type ProgramMinAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    visaDeadline?: true
    hotelDeadline?: true
    flightDeadline?: true
    passportDeadline?: true
    nbJoursMadina?: true
    nbJoursMakkah?: true
    exchange?: true
    prixAvionDH?: true
    prixVisaRiyal?: true
    profit?: true
  }

  export type ProgramMaxAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    visaDeadline?: true
    hotelDeadline?: true
    flightDeadline?: true
    passportDeadline?: true
    nbJoursMadina?: true
    nbJoursMakkah?: true
    exchange?: true
    prixAvionDH?: true
    prixVisaRiyal?: true
    profit?: true
  }

  export type ProgramCountAggregateInputType = {
    id?: true
    name?: true
    created_at?: true
    visaDeadline?: true
    hotelDeadline?: true
    flightDeadline?: true
    passportDeadline?: true
    nbJoursMadina?: true
    nbJoursMakkah?: true
    exchange?: true
    prixAvionDH?: true
    prixVisaRiyal?: true
    profit?: true
    _all?: true
  }

  export type ProgramAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Program to aggregate.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Programs
    **/
    _count?: true | ProgramCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramMaxAggregateInputType
  }

  export type GetProgramAggregateType<T extends ProgramAggregateArgs> = {
        [P in keyof T & keyof AggregateProgram]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgram[P]>
      : GetScalarType<T[P], AggregateProgram[P]>
  }




  export type ProgramGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramWhereInput
    orderBy?: ProgramOrderByWithAggregationInput | ProgramOrderByWithAggregationInput[]
    by: ProgramScalarFieldEnum[] | ProgramScalarFieldEnum
    having?: ProgramScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramCountAggregateInputType | true
    _avg?: ProgramAvgAggregateInputType
    _sum?: ProgramSumAggregateInputType
    _min?: ProgramMinAggregateInputType
    _max?: ProgramMaxAggregateInputType
  }

  export type ProgramGroupByOutputType = {
    id: number
    name: string
    created_at: Date
    visaDeadline: Date | null
    hotelDeadline: Date | null
    flightDeadline: Date | null
    passportDeadline: Date | null
    nbJoursMadina: number
    nbJoursMakkah: number
    exchange: number
    prixAvionDH: number
    prixVisaRiyal: number
    profit: number
    _count: ProgramCountAggregateOutputType | null
    _avg: ProgramAvgAggregateOutputType | null
    _sum: ProgramSumAggregateOutputType | null
    _min: ProgramMinAggregateOutputType | null
    _max: ProgramMaxAggregateOutputType | null
  }

  type GetProgramGroupByPayload<T extends ProgramGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramGroupByOutputType[P]>
        }
      >
    >


  export type ProgramSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    visaDeadline?: boolean
    hotelDeadline?: boolean
    flightDeadline?: boolean
    passportDeadline?: boolean
    nbJoursMadina?: boolean
    nbJoursMakkah?: boolean
    exchange?: boolean
    prixAvionDH?: boolean
    prixVisaRiyal?: boolean
    profit?: boolean
    expenses?: boolean | Program$expensesArgs<ExtArgs>
    hotelsMadina?: boolean | Program$hotelsMadinaArgs<ExtArgs>
    hotelsMakkah?: boolean | Program$hotelsMakkahArgs<ExtArgs>
    rooms?: boolean | Program$roomsArgs<ExtArgs>
    reservations?: boolean | Program$reservationsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    created_at?: boolean
    visaDeadline?: boolean
    hotelDeadline?: boolean
    flightDeadline?: boolean
    passportDeadline?: boolean
    nbJoursMadina?: boolean
    nbJoursMakkah?: boolean
    exchange?: boolean
    prixAvionDH?: boolean
    prixVisaRiyal?: boolean
    profit?: boolean
  }, ExtArgs["result"]["program"]>

  export type ProgramSelectScalar = {
    id?: boolean
    name?: boolean
    created_at?: boolean
    visaDeadline?: boolean
    hotelDeadline?: boolean
    flightDeadline?: boolean
    passportDeadline?: boolean
    nbJoursMadina?: boolean
    nbJoursMakkah?: boolean
    exchange?: boolean
    prixAvionDH?: boolean
    prixVisaRiyal?: boolean
    profit?: boolean
  }

  export type ProgramInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    expenses?: boolean | Program$expensesArgs<ExtArgs>
    hotelsMadina?: boolean | Program$hotelsMadinaArgs<ExtArgs>
    hotelsMakkah?: boolean | Program$hotelsMakkahArgs<ExtArgs>
    rooms?: boolean | Program$roomsArgs<ExtArgs>
    reservations?: boolean | Program$reservationsArgs<ExtArgs>
    _count?: boolean | ProgramCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProgramIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $ProgramPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Program"
    objects: {
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      hotelsMadina: Prisma.$ProgramHotelMadinaPayload<ExtArgs>[]
      hotelsMakkah: Prisma.$ProgramHotelMakkahPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
      reservations: Prisma.$ReservationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      created_at: Date
      visaDeadline: Date | null
      hotelDeadline: Date | null
      flightDeadline: Date | null
      passportDeadline: Date | null
      nbJoursMadina: number
      nbJoursMakkah: number
      exchange: number
      prixAvionDH: number
      prixVisaRiyal: number
      profit: number
    }, ExtArgs["result"]["program"]>
    composites: {}
  }

  type ProgramGetPayload<S extends boolean | null | undefined | ProgramDefaultArgs> = $Result.GetResult<Prisma.$ProgramPayload, S>

  type ProgramCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramCountAggregateInputType | true
    }

  export interface ProgramDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Program'], meta: { name: 'Program' } }
    /**
     * Find zero or one Program that matches the filter.
     * @param {ProgramFindUniqueArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramFindUniqueArgs>(args: SelectSubset<T, ProgramFindUniqueArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Program that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramFindUniqueOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Program that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramFindFirstArgs>(args?: SelectSubset<T, ProgramFindFirstArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Program that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindFirstOrThrowArgs} args - Arguments to find a Program
     * @example
     * // Get one Program
     * const program = await prisma.program.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Programs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Programs
     * const programs = await prisma.program.findMany()
     * 
     * // Get first 10 Programs
     * const programs = await prisma.program.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programWithIdOnly = await prisma.program.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramFindManyArgs>(args?: SelectSubset<T, ProgramFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Program.
     * @param {ProgramCreateArgs} args - Arguments to create a Program.
     * @example
     * // Create one Program
     * const Program = await prisma.program.create({
     *   data: {
     *     // ... data to create a Program
     *   }
     * })
     * 
     */
    create<T extends ProgramCreateArgs>(args: SelectSubset<T, ProgramCreateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Programs.
     * @param {ProgramCreateManyArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramCreateManyArgs>(args?: SelectSubset<T, ProgramCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Programs and returns the data saved in the database.
     * @param {ProgramCreateManyAndReturnArgs} args - Arguments to create many Programs.
     * @example
     * // Create many Programs
     * const program = await prisma.program.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Programs and only return the `id`
     * const programWithIdOnly = await prisma.program.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Program.
     * @param {ProgramDeleteArgs} args - Arguments to delete one Program.
     * @example
     * // Delete one Program
     * const Program = await prisma.program.delete({
     *   where: {
     *     // ... filter to delete one Program
     *   }
     * })
     * 
     */
    delete<T extends ProgramDeleteArgs>(args: SelectSubset<T, ProgramDeleteArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Program.
     * @param {ProgramUpdateArgs} args - Arguments to update one Program.
     * @example
     * // Update one Program
     * const program = await prisma.program.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramUpdateArgs>(args: SelectSubset<T, ProgramUpdateArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Programs.
     * @param {ProgramDeleteManyArgs} args - Arguments to filter Programs to delete.
     * @example
     * // Delete a few Programs
     * const { count } = await prisma.program.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramDeleteManyArgs>(args?: SelectSubset<T, ProgramDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Programs
     * const program = await prisma.program.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramUpdateManyArgs>(args: SelectSubset<T, ProgramUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Program.
     * @param {ProgramUpsertArgs} args - Arguments to update or create a Program.
     * @example
     * // Update or create a Program
     * const program = await prisma.program.upsert({
     *   create: {
     *     // ... data to create a Program
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Program we want to update
     *   }
     * })
     */
    upsert<T extends ProgramUpsertArgs>(args: SelectSubset<T, ProgramUpsertArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Programs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramCountArgs} args - Arguments to filter Programs to count.
     * @example
     * // Count the number of Programs
     * const count = await prisma.program.count({
     *   where: {
     *     // ... the filter for the Programs we want to count
     *   }
     * })
    **/
    count<T extends ProgramCountArgs>(
      args?: Subset<T, ProgramCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramAggregateArgs>(args: Subset<T, ProgramAggregateArgs>): Prisma.PrismaPromise<GetProgramAggregateType<T>>

    /**
     * Group by Program.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramGroupByArgs['orderBy'] }
        : { orderBy?: ProgramGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Program model
   */
  readonly fields: ProgramFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Program.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    expenses<T extends Program$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Program$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    hotelsMadina<T extends Program$hotelsMadinaArgs<ExtArgs> = {}>(args?: Subset<T, Program$hotelsMadinaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "findMany"> | Null>
    hotelsMakkah<T extends Program$hotelsMakkahArgs<ExtArgs> = {}>(args?: Subset<T, Program$hotelsMakkahArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "findMany"> | Null>
    rooms<T extends Program$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Program$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany"> | Null>
    reservations<T extends Program$reservationsArgs<ExtArgs> = {}>(args?: Subset<T, Program$reservationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Program model
   */ 
  interface ProgramFieldRefs {
    readonly id: FieldRef<"Program", 'Int'>
    readonly name: FieldRef<"Program", 'String'>
    readonly created_at: FieldRef<"Program", 'DateTime'>
    readonly visaDeadline: FieldRef<"Program", 'DateTime'>
    readonly hotelDeadline: FieldRef<"Program", 'DateTime'>
    readonly flightDeadline: FieldRef<"Program", 'DateTime'>
    readonly passportDeadline: FieldRef<"Program", 'DateTime'>
    readonly nbJoursMadina: FieldRef<"Program", 'Int'>
    readonly nbJoursMakkah: FieldRef<"Program", 'Int'>
    readonly exchange: FieldRef<"Program", 'Float'>
    readonly prixAvionDH: FieldRef<"Program", 'Float'>
    readonly prixVisaRiyal: FieldRef<"Program", 'Float'>
    readonly profit: FieldRef<"Program", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * Program findUnique
   */
  export type ProgramFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findUniqueOrThrow
   */
  export type ProgramFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program findFirst
   */
  export type ProgramFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findFirstOrThrow
   */
  export type ProgramFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Program to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Programs.
     */
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program findMany
   */
  export type ProgramFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter, which Programs to fetch.
     */
    where?: ProgramWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Programs to fetch.
     */
    orderBy?: ProgramOrderByWithRelationInput | ProgramOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Programs.
     */
    cursor?: ProgramWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Programs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Programs.
     */
    skip?: number
    distinct?: ProgramScalarFieldEnum | ProgramScalarFieldEnum[]
  }

  /**
   * Program create
   */
  export type ProgramCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to create a Program.
     */
    data: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
  }

  /**
   * Program createMany
   */
  export type ProgramCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program createManyAndReturn
   */
  export type ProgramCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Programs.
     */
    data: ProgramCreateManyInput | ProgramCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Program update
   */
  export type ProgramUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The data needed to update a Program.
     */
    data: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
    /**
     * Choose, which Program to update.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program updateMany
   */
  export type ProgramUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Programs.
     */
    data: XOR<ProgramUpdateManyMutationInput, ProgramUncheckedUpdateManyInput>
    /**
     * Filter which Programs to update
     */
    where?: ProgramWhereInput
  }

  /**
   * Program upsert
   */
  export type ProgramUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * The filter to search for the Program to update in case it exists.
     */
    where: ProgramWhereUniqueInput
    /**
     * In case the Program found by the `where` argument doesn't exist, create a new Program with this data.
     */
    create: XOR<ProgramCreateInput, ProgramUncheckedCreateInput>
    /**
     * In case the Program was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramUpdateInput, ProgramUncheckedUpdateInput>
  }

  /**
   * Program delete
   */
  export type ProgramDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    /**
     * Filter which Program to delete.
     */
    where: ProgramWhereUniqueInput
  }

  /**
   * Program deleteMany
   */
  export type ProgramDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Programs to delete
     */
    where?: ProgramWhereInput
  }

  /**
   * Program.expenses
   */
  export type Program$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Program.hotelsMadina
   */
  export type Program$hotelsMadinaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    where?: ProgramHotelMadinaWhereInput
    orderBy?: ProgramHotelMadinaOrderByWithRelationInput | ProgramHotelMadinaOrderByWithRelationInput[]
    cursor?: ProgramHotelMadinaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramHotelMadinaScalarFieldEnum | ProgramHotelMadinaScalarFieldEnum[]
  }

  /**
   * Program.hotelsMakkah
   */
  export type Program$hotelsMakkahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    where?: ProgramHotelMakkahWhereInput
    orderBy?: ProgramHotelMakkahOrderByWithRelationInput | ProgramHotelMakkahOrderByWithRelationInput[]
    cursor?: ProgramHotelMakkahWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramHotelMakkahScalarFieldEnum | ProgramHotelMakkahScalarFieldEnum[]
  }

  /**
   * Program.rooms
   */
  export type Program$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Program.reservations
   */
  export type Program$reservationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    cursor?: ReservationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Program without action
   */
  export type ProgramDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
  }


  /**
   * Model Hotel
   */

  export type AggregateHotel = {
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  export type HotelAvgAggregateOutputType = {
    id: number | null
  }

  export type HotelSumAggregateOutputType = {
    id: number | null
  }

  export type HotelMinAggregateOutputType = {
    id: number | null
    name: string | null
    city: $Enums.City | null
  }

  export type HotelMaxAggregateOutputType = {
    id: number | null
    name: string | null
    city: $Enums.City | null
  }

  export type HotelCountAggregateOutputType = {
    id: number
    name: number
    city: number
    _all: number
  }


  export type HotelAvgAggregateInputType = {
    id?: true
  }

  export type HotelSumAggregateInputType = {
    id?: true
  }

  export type HotelMinAggregateInputType = {
    id?: true
    name?: true
    city?: true
  }

  export type HotelMaxAggregateInputType = {
    id?: true
    name?: true
    city?: true
  }

  export type HotelCountAggregateInputType = {
    id?: true
    name?: true
    city?: true
    _all?: true
  }

  export type HotelAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotel to aggregate.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Hotels
    **/
    _count?: true | HotelCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HotelAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HotelSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HotelMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HotelMaxAggregateInputType
  }

  export type GetHotelAggregateType<T extends HotelAggregateArgs> = {
        [P in keyof T & keyof AggregateHotel]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHotel[P]>
      : GetScalarType<T[P], AggregateHotel[P]>
  }




  export type HotelGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HotelWhereInput
    orderBy?: HotelOrderByWithAggregationInput | HotelOrderByWithAggregationInput[]
    by: HotelScalarFieldEnum[] | HotelScalarFieldEnum
    having?: HotelScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HotelCountAggregateInputType | true
    _avg?: HotelAvgAggregateInputType
    _sum?: HotelSumAggregateInputType
    _min?: HotelMinAggregateInputType
    _max?: HotelMaxAggregateInputType
  }

  export type HotelGroupByOutputType = {
    id: number
    name: string
    city: $Enums.City
    _count: HotelCountAggregateOutputType | null
    _avg: HotelAvgAggregateOutputType | null
    _sum: HotelSumAggregateOutputType | null
    _min: HotelMinAggregateOutputType | null
    _max: HotelMaxAggregateOutputType | null
  }

  type GetHotelGroupByPayload<T extends HotelGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HotelGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HotelGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HotelGroupByOutputType[P]>
            : GetScalarType<T[P], HotelGroupByOutputType[P]>
        }
      >
    >


  export type HotelSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
    programsMadina?: boolean | Hotel$programsMadinaArgs<ExtArgs>
    programsMakkah?: boolean | Hotel$programsMakkahArgs<ExtArgs>
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    city?: boolean
  }, ExtArgs["result"]["hotel"]>

  export type HotelSelectScalar = {
    id?: boolean
    name?: boolean
    city?: boolean
  }

  export type HotelInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    programsMadina?: boolean | Hotel$programsMadinaArgs<ExtArgs>
    programsMakkah?: boolean | Hotel$programsMakkahArgs<ExtArgs>
    rooms?: boolean | Hotel$roomsArgs<ExtArgs>
    _count?: boolean | HotelCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HotelIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $HotelPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Hotel"
    objects: {
      programsMadina: Prisma.$ProgramHotelMadinaPayload<ExtArgs>[]
      programsMakkah: Prisma.$ProgramHotelMakkahPayload<ExtArgs>[]
      rooms: Prisma.$RoomPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      name: string
      city: $Enums.City
    }, ExtArgs["result"]["hotel"]>
    composites: {}
  }

  type HotelGetPayload<S extends boolean | null | undefined | HotelDefaultArgs> = $Result.GetResult<Prisma.$HotelPayload, S>

  type HotelCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HotelFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HotelCountAggregateInputType | true
    }

  export interface HotelDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Hotel'], meta: { name: 'Hotel' } }
    /**
     * Find zero or one Hotel that matches the filter.
     * @param {HotelFindUniqueArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HotelFindUniqueArgs>(args: SelectSubset<T, HotelFindUniqueArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Hotel that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HotelFindUniqueOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HotelFindUniqueOrThrowArgs>(args: SelectSubset<T, HotelFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Hotel that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HotelFindFirstArgs>(args?: SelectSubset<T, HotelFindFirstArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Hotel that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindFirstOrThrowArgs} args - Arguments to find a Hotel
     * @example
     * // Get one Hotel
     * const hotel = await prisma.hotel.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HotelFindFirstOrThrowArgs>(args?: SelectSubset<T, HotelFindFirstOrThrowArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Hotels that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Hotels
     * const hotels = await prisma.hotel.findMany()
     * 
     * // Get first 10 Hotels
     * const hotels = await prisma.hotel.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const hotelWithIdOnly = await prisma.hotel.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HotelFindManyArgs>(args?: SelectSubset<T, HotelFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Hotel.
     * @param {HotelCreateArgs} args - Arguments to create a Hotel.
     * @example
     * // Create one Hotel
     * const Hotel = await prisma.hotel.create({
     *   data: {
     *     // ... data to create a Hotel
     *   }
     * })
     * 
     */
    create<T extends HotelCreateArgs>(args: SelectSubset<T, HotelCreateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Hotels.
     * @param {HotelCreateManyArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HotelCreateManyArgs>(args?: SelectSubset<T, HotelCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Hotels and returns the data saved in the database.
     * @param {HotelCreateManyAndReturnArgs} args - Arguments to create many Hotels.
     * @example
     * // Create many Hotels
     * const hotel = await prisma.hotel.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Hotels and only return the `id`
     * const hotelWithIdOnly = await prisma.hotel.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HotelCreateManyAndReturnArgs>(args?: SelectSubset<T, HotelCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Hotel.
     * @param {HotelDeleteArgs} args - Arguments to delete one Hotel.
     * @example
     * // Delete one Hotel
     * const Hotel = await prisma.hotel.delete({
     *   where: {
     *     // ... filter to delete one Hotel
     *   }
     * })
     * 
     */
    delete<T extends HotelDeleteArgs>(args: SelectSubset<T, HotelDeleteArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Hotel.
     * @param {HotelUpdateArgs} args - Arguments to update one Hotel.
     * @example
     * // Update one Hotel
     * const hotel = await prisma.hotel.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HotelUpdateArgs>(args: SelectSubset<T, HotelUpdateArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Hotels.
     * @param {HotelDeleteManyArgs} args - Arguments to filter Hotels to delete.
     * @example
     * // Delete a few Hotels
     * const { count } = await prisma.hotel.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HotelDeleteManyArgs>(args?: SelectSubset<T, HotelDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Hotels
     * const hotel = await prisma.hotel.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HotelUpdateManyArgs>(args: SelectSubset<T, HotelUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Hotel.
     * @param {HotelUpsertArgs} args - Arguments to update or create a Hotel.
     * @example
     * // Update or create a Hotel
     * const hotel = await prisma.hotel.upsert({
     *   create: {
     *     // ... data to create a Hotel
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Hotel we want to update
     *   }
     * })
     */
    upsert<T extends HotelUpsertArgs>(args: SelectSubset<T, HotelUpsertArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Hotels.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelCountArgs} args - Arguments to filter Hotels to count.
     * @example
     * // Count the number of Hotels
     * const count = await prisma.hotel.count({
     *   where: {
     *     // ... the filter for the Hotels we want to count
     *   }
     * })
    **/
    count<T extends HotelCountArgs>(
      args?: Subset<T, HotelCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HotelCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HotelAggregateArgs>(args: Subset<T, HotelAggregateArgs>): Prisma.PrismaPromise<GetHotelAggregateType<T>>

    /**
     * Group by Hotel.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HotelGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HotelGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HotelGroupByArgs['orderBy'] }
        : { orderBy?: HotelGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HotelGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHotelGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Hotel model
   */
  readonly fields: HotelFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Hotel.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HotelClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    programsMadina<T extends Hotel$programsMadinaArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$programsMadinaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "findMany"> | Null>
    programsMakkah<T extends Hotel$programsMakkahArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$programsMakkahArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "findMany"> | Null>
    rooms<T extends Hotel$roomsArgs<ExtArgs> = {}>(args?: Subset<T, Hotel$roomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Hotel model
   */ 
  interface HotelFieldRefs {
    readonly id: FieldRef<"Hotel", 'Int'>
    readonly name: FieldRef<"Hotel", 'String'>
    readonly city: FieldRef<"Hotel", 'City'>
  }
    

  // Custom InputTypes
  /**
   * Hotel findUnique
   */
  export type HotelFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findUniqueOrThrow
   */
  export type HotelFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel findFirst
   */
  export type HotelFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findFirstOrThrow
   */
  export type HotelFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotel to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Hotels.
     */
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel findMany
   */
  export type HotelFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter, which Hotels to fetch.
     */
    where?: HotelWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Hotels to fetch.
     */
    orderBy?: HotelOrderByWithRelationInput | HotelOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Hotels.
     */
    cursor?: HotelWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Hotels from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Hotels.
     */
    skip?: number
    distinct?: HotelScalarFieldEnum | HotelScalarFieldEnum[]
  }

  /**
   * Hotel create
   */
  export type HotelCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to create a Hotel.
     */
    data: XOR<HotelCreateInput, HotelUncheckedCreateInput>
  }

  /**
   * Hotel createMany
   */
  export type HotelCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotel createManyAndReturn
   */
  export type HotelCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Hotels.
     */
    data: HotelCreateManyInput | HotelCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Hotel update
   */
  export type HotelUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The data needed to update a Hotel.
     */
    data: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
    /**
     * Choose, which Hotel to update.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel updateMany
   */
  export type HotelUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Hotels.
     */
    data: XOR<HotelUpdateManyMutationInput, HotelUncheckedUpdateManyInput>
    /**
     * Filter which Hotels to update
     */
    where?: HotelWhereInput
  }

  /**
   * Hotel upsert
   */
  export type HotelUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * The filter to search for the Hotel to update in case it exists.
     */
    where: HotelWhereUniqueInput
    /**
     * In case the Hotel found by the `where` argument doesn't exist, create a new Hotel with this data.
     */
    create: XOR<HotelCreateInput, HotelUncheckedCreateInput>
    /**
     * In case the Hotel was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HotelUpdateInput, HotelUncheckedUpdateInput>
  }

  /**
   * Hotel delete
   */
  export type HotelDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
    /**
     * Filter which Hotel to delete.
     */
    where: HotelWhereUniqueInput
  }

  /**
   * Hotel deleteMany
   */
  export type HotelDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Hotels to delete
     */
    where?: HotelWhereInput
  }

  /**
   * Hotel.programsMadina
   */
  export type Hotel$programsMadinaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    where?: ProgramHotelMadinaWhereInput
    orderBy?: ProgramHotelMadinaOrderByWithRelationInput | ProgramHotelMadinaOrderByWithRelationInput[]
    cursor?: ProgramHotelMadinaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramHotelMadinaScalarFieldEnum | ProgramHotelMadinaScalarFieldEnum[]
  }

  /**
   * Hotel.programsMakkah
   */
  export type Hotel$programsMakkahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    where?: ProgramHotelMakkahWhereInput
    orderBy?: ProgramHotelMakkahOrderByWithRelationInput | ProgramHotelMakkahOrderByWithRelationInput[]
    cursor?: ProgramHotelMakkahWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProgramHotelMakkahScalarFieldEnum | ProgramHotelMakkahScalarFieldEnum[]
  }

  /**
   * Hotel.rooms
   */
  export type Hotel$roomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    cursor?: RoomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Hotel without action
   */
  export type HotelDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Hotel
     */
    select?: HotelSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HotelInclude<ExtArgs> | null
  }


  /**
   * Model ProgramHotelMadina
   */

  export type AggregateProgramHotelMadina = {
    _count: ProgramHotelMadinaCountAggregateOutputType | null
    _avg: ProgramHotelMadinaAvgAggregateOutputType | null
    _sum: ProgramHotelMadinaSumAggregateOutputType | null
    _min: ProgramHotelMadinaMinAggregateOutputType | null
    _max: ProgramHotelMadinaMaxAggregateOutputType | null
  }

  export type ProgramHotelMadinaAvgAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
  }

  export type ProgramHotelMadinaSumAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
  }

  export type ProgramHotelMadinaMinAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
  }

  export type ProgramHotelMadinaMaxAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
  }

  export type ProgramHotelMadinaCountAggregateOutputType = {
    id: number
    programId: number
    hotelId: number
    _all: number
  }


  export type ProgramHotelMadinaAvgAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
  }

  export type ProgramHotelMadinaSumAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
  }

  export type ProgramHotelMadinaMinAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
  }

  export type ProgramHotelMadinaMaxAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
  }

  export type ProgramHotelMadinaCountAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
    _all?: true
  }

  export type ProgramHotelMadinaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramHotelMadina to aggregate.
     */
    where?: ProgramHotelMadinaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramHotelMadinas to fetch.
     */
    orderBy?: ProgramHotelMadinaOrderByWithRelationInput | ProgramHotelMadinaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramHotelMadinaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramHotelMadinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramHotelMadinas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramHotelMadinas
    **/
    _count?: true | ProgramHotelMadinaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramHotelMadinaAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramHotelMadinaSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramHotelMadinaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramHotelMadinaMaxAggregateInputType
  }

  export type GetProgramHotelMadinaAggregateType<T extends ProgramHotelMadinaAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramHotelMadina]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramHotelMadina[P]>
      : GetScalarType<T[P], AggregateProgramHotelMadina[P]>
  }




  export type ProgramHotelMadinaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramHotelMadinaWhereInput
    orderBy?: ProgramHotelMadinaOrderByWithAggregationInput | ProgramHotelMadinaOrderByWithAggregationInput[]
    by: ProgramHotelMadinaScalarFieldEnum[] | ProgramHotelMadinaScalarFieldEnum
    having?: ProgramHotelMadinaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramHotelMadinaCountAggregateInputType | true
    _avg?: ProgramHotelMadinaAvgAggregateInputType
    _sum?: ProgramHotelMadinaSumAggregateInputType
    _min?: ProgramHotelMadinaMinAggregateInputType
    _max?: ProgramHotelMadinaMaxAggregateInputType
  }

  export type ProgramHotelMadinaGroupByOutputType = {
    id: number
    programId: number
    hotelId: number
    _count: ProgramHotelMadinaCountAggregateOutputType | null
    _avg: ProgramHotelMadinaAvgAggregateOutputType | null
    _sum: ProgramHotelMadinaSumAggregateOutputType | null
    _min: ProgramHotelMadinaMinAggregateOutputType | null
    _max: ProgramHotelMadinaMaxAggregateOutputType | null
  }

  type GetProgramHotelMadinaGroupByPayload<T extends ProgramHotelMadinaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramHotelMadinaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramHotelMadinaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramHotelMadinaGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramHotelMadinaGroupByOutputType[P]>
        }
      >
    >


  export type ProgramHotelMadinaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    hotelId?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programHotelMadina"]>

  export type ProgramHotelMadinaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    hotelId?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programHotelMadina"]>

  export type ProgramHotelMadinaSelectScalar = {
    id?: boolean
    programId?: boolean
    hotelId?: boolean
  }

  export type ProgramHotelMadinaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }
  export type ProgramHotelMadinaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $ProgramHotelMadinaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramHotelMadina"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      hotel: Prisma.$HotelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      programId: number
      hotelId: number
    }, ExtArgs["result"]["programHotelMadina"]>
    composites: {}
  }

  type ProgramHotelMadinaGetPayload<S extends boolean | null | undefined | ProgramHotelMadinaDefaultArgs> = $Result.GetResult<Prisma.$ProgramHotelMadinaPayload, S>

  type ProgramHotelMadinaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramHotelMadinaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramHotelMadinaCountAggregateInputType | true
    }

  export interface ProgramHotelMadinaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramHotelMadina'], meta: { name: 'ProgramHotelMadina' } }
    /**
     * Find zero or one ProgramHotelMadina that matches the filter.
     * @param {ProgramHotelMadinaFindUniqueArgs} args - Arguments to find a ProgramHotelMadina
     * @example
     * // Get one ProgramHotelMadina
     * const programHotelMadina = await prisma.programHotelMadina.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramHotelMadinaFindUniqueArgs>(args: SelectSubset<T, ProgramHotelMadinaFindUniqueArgs<ExtArgs>>): Prisma__ProgramHotelMadinaClient<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgramHotelMadina that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramHotelMadinaFindUniqueOrThrowArgs} args - Arguments to find a ProgramHotelMadina
     * @example
     * // Get one ProgramHotelMadina
     * const programHotelMadina = await prisma.programHotelMadina.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramHotelMadinaFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramHotelMadinaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramHotelMadinaClient<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgramHotelMadina that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMadinaFindFirstArgs} args - Arguments to find a ProgramHotelMadina
     * @example
     * // Get one ProgramHotelMadina
     * const programHotelMadina = await prisma.programHotelMadina.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramHotelMadinaFindFirstArgs>(args?: SelectSubset<T, ProgramHotelMadinaFindFirstArgs<ExtArgs>>): Prisma__ProgramHotelMadinaClient<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgramHotelMadina that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMadinaFindFirstOrThrowArgs} args - Arguments to find a ProgramHotelMadina
     * @example
     * // Get one ProgramHotelMadina
     * const programHotelMadina = await prisma.programHotelMadina.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramHotelMadinaFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramHotelMadinaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramHotelMadinaClient<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgramHotelMadinas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMadinaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramHotelMadinas
     * const programHotelMadinas = await prisma.programHotelMadina.findMany()
     * 
     * // Get first 10 ProgramHotelMadinas
     * const programHotelMadinas = await prisma.programHotelMadina.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programHotelMadinaWithIdOnly = await prisma.programHotelMadina.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramHotelMadinaFindManyArgs>(args?: SelectSubset<T, ProgramHotelMadinaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgramHotelMadina.
     * @param {ProgramHotelMadinaCreateArgs} args - Arguments to create a ProgramHotelMadina.
     * @example
     * // Create one ProgramHotelMadina
     * const ProgramHotelMadina = await prisma.programHotelMadina.create({
     *   data: {
     *     // ... data to create a ProgramHotelMadina
     *   }
     * })
     * 
     */
    create<T extends ProgramHotelMadinaCreateArgs>(args: SelectSubset<T, ProgramHotelMadinaCreateArgs<ExtArgs>>): Prisma__ProgramHotelMadinaClient<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgramHotelMadinas.
     * @param {ProgramHotelMadinaCreateManyArgs} args - Arguments to create many ProgramHotelMadinas.
     * @example
     * // Create many ProgramHotelMadinas
     * const programHotelMadina = await prisma.programHotelMadina.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramHotelMadinaCreateManyArgs>(args?: SelectSubset<T, ProgramHotelMadinaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramHotelMadinas and returns the data saved in the database.
     * @param {ProgramHotelMadinaCreateManyAndReturnArgs} args - Arguments to create many ProgramHotelMadinas.
     * @example
     * // Create many ProgramHotelMadinas
     * const programHotelMadina = await prisma.programHotelMadina.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramHotelMadinas and only return the `id`
     * const programHotelMadinaWithIdOnly = await prisma.programHotelMadina.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramHotelMadinaCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramHotelMadinaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgramHotelMadina.
     * @param {ProgramHotelMadinaDeleteArgs} args - Arguments to delete one ProgramHotelMadina.
     * @example
     * // Delete one ProgramHotelMadina
     * const ProgramHotelMadina = await prisma.programHotelMadina.delete({
     *   where: {
     *     // ... filter to delete one ProgramHotelMadina
     *   }
     * })
     * 
     */
    delete<T extends ProgramHotelMadinaDeleteArgs>(args: SelectSubset<T, ProgramHotelMadinaDeleteArgs<ExtArgs>>): Prisma__ProgramHotelMadinaClient<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgramHotelMadina.
     * @param {ProgramHotelMadinaUpdateArgs} args - Arguments to update one ProgramHotelMadina.
     * @example
     * // Update one ProgramHotelMadina
     * const programHotelMadina = await prisma.programHotelMadina.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramHotelMadinaUpdateArgs>(args: SelectSubset<T, ProgramHotelMadinaUpdateArgs<ExtArgs>>): Prisma__ProgramHotelMadinaClient<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgramHotelMadinas.
     * @param {ProgramHotelMadinaDeleteManyArgs} args - Arguments to filter ProgramHotelMadinas to delete.
     * @example
     * // Delete a few ProgramHotelMadinas
     * const { count } = await prisma.programHotelMadina.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramHotelMadinaDeleteManyArgs>(args?: SelectSubset<T, ProgramHotelMadinaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramHotelMadinas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMadinaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramHotelMadinas
     * const programHotelMadina = await prisma.programHotelMadina.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramHotelMadinaUpdateManyArgs>(args: SelectSubset<T, ProgramHotelMadinaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramHotelMadina.
     * @param {ProgramHotelMadinaUpsertArgs} args - Arguments to update or create a ProgramHotelMadina.
     * @example
     * // Update or create a ProgramHotelMadina
     * const programHotelMadina = await prisma.programHotelMadina.upsert({
     *   create: {
     *     // ... data to create a ProgramHotelMadina
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramHotelMadina we want to update
     *   }
     * })
     */
    upsert<T extends ProgramHotelMadinaUpsertArgs>(args: SelectSubset<T, ProgramHotelMadinaUpsertArgs<ExtArgs>>): Prisma__ProgramHotelMadinaClient<$Result.GetResult<Prisma.$ProgramHotelMadinaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgramHotelMadinas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMadinaCountArgs} args - Arguments to filter ProgramHotelMadinas to count.
     * @example
     * // Count the number of ProgramHotelMadinas
     * const count = await prisma.programHotelMadina.count({
     *   where: {
     *     // ... the filter for the ProgramHotelMadinas we want to count
     *   }
     * })
    **/
    count<T extends ProgramHotelMadinaCountArgs>(
      args?: Subset<T, ProgramHotelMadinaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramHotelMadinaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramHotelMadina.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMadinaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramHotelMadinaAggregateArgs>(args: Subset<T, ProgramHotelMadinaAggregateArgs>): Prisma.PrismaPromise<GetProgramHotelMadinaAggregateType<T>>

    /**
     * Group by ProgramHotelMadina.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMadinaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramHotelMadinaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramHotelMadinaGroupByArgs['orderBy'] }
        : { orderBy?: ProgramHotelMadinaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramHotelMadinaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramHotelMadinaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramHotelMadina model
   */
  readonly fields: ProgramHotelMadinaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramHotelMadina.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramHotelMadinaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramHotelMadina model
   */ 
  interface ProgramHotelMadinaFieldRefs {
    readonly id: FieldRef<"ProgramHotelMadina", 'Int'>
    readonly programId: FieldRef<"ProgramHotelMadina", 'Int'>
    readonly hotelId: FieldRef<"ProgramHotelMadina", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProgramHotelMadina findUnique
   */
  export type ProgramHotelMadinaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMadina to fetch.
     */
    where: ProgramHotelMadinaWhereUniqueInput
  }

  /**
   * ProgramHotelMadina findUniqueOrThrow
   */
  export type ProgramHotelMadinaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMadina to fetch.
     */
    where: ProgramHotelMadinaWhereUniqueInput
  }

  /**
   * ProgramHotelMadina findFirst
   */
  export type ProgramHotelMadinaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMadina to fetch.
     */
    where?: ProgramHotelMadinaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramHotelMadinas to fetch.
     */
    orderBy?: ProgramHotelMadinaOrderByWithRelationInput | ProgramHotelMadinaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramHotelMadinas.
     */
    cursor?: ProgramHotelMadinaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramHotelMadinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramHotelMadinas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramHotelMadinas.
     */
    distinct?: ProgramHotelMadinaScalarFieldEnum | ProgramHotelMadinaScalarFieldEnum[]
  }

  /**
   * ProgramHotelMadina findFirstOrThrow
   */
  export type ProgramHotelMadinaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMadina to fetch.
     */
    where?: ProgramHotelMadinaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramHotelMadinas to fetch.
     */
    orderBy?: ProgramHotelMadinaOrderByWithRelationInput | ProgramHotelMadinaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramHotelMadinas.
     */
    cursor?: ProgramHotelMadinaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramHotelMadinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramHotelMadinas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramHotelMadinas.
     */
    distinct?: ProgramHotelMadinaScalarFieldEnum | ProgramHotelMadinaScalarFieldEnum[]
  }

  /**
   * ProgramHotelMadina findMany
   */
  export type ProgramHotelMadinaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMadinas to fetch.
     */
    where?: ProgramHotelMadinaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramHotelMadinas to fetch.
     */
    orderBy?: ProgramHotelMadinaOrderByWithRelationInput | ProgramHotelMadinaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramHotelMadinas.
     */
    cursor?: ProgramHotelMadinaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramHotelMadinas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramHotelMadinas.
     */
    skip?: number
    distinct?: ProgramHotelMadinaScalarFieldEnum | ProgramHotelMadinaScalarFieldEnum[]
  }

  /**
   * ProgramHotelMadina create
   */
  export type ProgramHotelMadinaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramHotelMadina.
     */
    data: XOR<ProgramHotelMadinaCreateInput, ProgramHotelMadinaUncheckedCreateInput>
  }

  /**
   * ProgramHotelMadina createMany
   */
  export type ProgramHotelMadinaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramHotelMadinas.
     */
    data: ProgramHotelMadinaCreateManyInput | ProgramHotelMadinaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramHotelMadina createManyAndReturn
   */
  export type ProgramHotelMadinaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgramHotelMadinas.
     */
    data: ProgramHotelMadinaCreateManyInput | ProgramHotelMadinaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramHotelMadina update
   */
  export type ProgramHotelMadinaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramHotelMadina.
     */
    data: XOR<ProgramHotelMadinaUpdateInput, ProgramHotelMadinaUncheckedUpdateInput>
    /**
     * Choose, which ProgramHotelMadina to update.
     */
    where: ProgramHotelMadinaWhereUniqueInput
  }

  /**
   * ProgramHotelMadina updateMany
   */
  export type ProgramHotelMadinaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramHotelMadinas.
     */
    data: XOR<ProgramHotelMadinaUpdateManyMutationInput, ProgramHotelMadinaUncheckedUpdateManyInput>
    /**
     * Filter which ProgramHotelMadinas to update
     */
    where?: ProgramHotelMadinaWhereInput
  }

  /**
   * ProgramHotelMadina upsert
   */
  export type ProgramHotelMadinaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramHotelMadina to update in case it exists.
     */
    where: ProgramHotelMadinaWhereUniqueInput
    /**
     * In case the ProgramHotelMadina found by the `where` argument doesn't exist, create a new ProgramHotelMadina with this data.
     */
    create: XOR<ProgramHotelMadinaCreateInput, ProgramHotelMadinaUncheckedCreateInput>
    /**
     * In case the ProgramHotelMadina was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramHotelMadinaUpdateInput, ProgramHotelMadinaUncheckedUpdateInput>
  }

  /**
   * ProgramHotelMadina delete
   */
  export type ProgramHotelMadinaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
    /**
     * Filter which ProgramHotelMadina to delete.
     */
    where: ProgramHotelMadinaWhereUniqueInput
  }

  /**
   * ProgramHotelMadina deleteMany
   */
  export type ProgramHotelMadinaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramHotelMadinas to delete
     */
    where?: ProgramHotelMadinaWhereInput
  }

  /**
   * ProgramHotelMadina without action
   */
  export type ProgramHotelMadinaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMadina
     */
    select?: ProgramHotelMadinaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMadinaInclude<ExtArgs> | null
  }


  /**
   * Model ProgramHotelMakkah
   */

  export type AggregateProgramHotelMakkah = {
    _count: ProgramHotelMakkahCountAggregateOutputType | null
    _avg: ProgramHotelMakkahAvgAggregateOutputType | null
    _sum: ProgramHotelMakkahSumAggregateOutputType | null
    _min: ProgramHotelMakkahMinAggregateOutputType | null
    _max: ProgramHotelMakkahMaxAggregateOutputType | null
  }

  export type ProgramHotelMakkahAvgAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
  }

  export type ProgramHotelMakkahSumAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
  }

  export type ProgramHotelMakkahMinAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
  }

  export type ProgramHotelMakkahMaxAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
  }

  export type ProgramHotelMakkahCountAggregateOutputType = {
    id: number
    programId: number
    hotelId: number
    _all: number
  }


  export type ProgramHotelMakkahAvgAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
  }

  export type ProgramHotelMakkahSumAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
  }

  export type ProgramHotelMakkahMinAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
  }

  export type ProgramHotelMakkahMaxAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
  }

  export type ProgramHotelMakkahCountAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
    _all?: true
  }

  export type ProgramHotelMakkahAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramHotelMakkah to aggregate.
     */
    where?: ProgramHotelMakkahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramHotelMakkahs to fetch.
     */
    orderBy?: ProgramHotelMakkahOrderByWithRelationInput | ProgramHotelMakkahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProgramHotelMakkahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramHotelMakkahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramHotelMakkahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProgramHotelMakkahs
    **/
    _count?: true | ProgramHotelMakkahCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProgramHotelMakkahAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProgramHotelMakkahSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProgramHotelMakkahMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProgramHotelMakkahMaxAggregateInputType
  }

  export type GetProgramHotelMakkahAggregateType<T extends ProgramHotelMakkahAggregateArgs> = {
        [P in keyof T & keyof AggregateProgramHotelMakkah]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProgramHotelMakkah[P]>
      : GetScalarType<T[P], AggregateProgramHotelMakkah[P]>
  }




  export type ProgramHotelMakkahGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProgramHotelMakkahWhereInput
    orderBy?: ProgramHotelMakkahOrderByWithAggregationInput | ProgramHotelMakkahOrderByWithAggregationInput[]
    by: ProgramHotelMakkahScalarFieldEnum[] | ProgramHotelMakkahScalarFieldEnum
    having?: ProgramHotelMakkahScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProgramHotelMakkahCountAggregateInputType | true
    _avg?: ProgramHotelMakkahAvgAggregateInputType
    _sum?: ProgramHotelMakkahSumAggregateInputType
    _min?: ProgramHotelMakkahMinAggregateInputType
    _max?: ProgramHotelMakkahMaxAggregateInputType
  }

  export type ProgramHotelMakkahGroupByOutputType = {
    id: number
    programId: number
    hotelId: number
    _count: ProgramHotelMakkahCountAggregateOutputType | null
    _avg: ProgramHotelMakkahAvgAggregateOutputType | null
    _sum: ProgramHotelMakkahSumAggregateOutputType | null
    _min: ProgramHotelMakkahMinAggregateOutputType | null
    _max: ProgramHotelMakkahMaxAggregateOutputType | null
  }

  type GetProgramHotelMakkahGroupByPayload<T extends ProgramHotelMakkahGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProgramHotelMakkahGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProgramHotelMakkahGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProgramHotelMakkahGroupByOutputType[P]>
            : GetScalarType<T[P], ProgramHotelMakkahGroupByOutputType[P]>
        }
      >
    >


  export type ProgramHotelMakkahSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    hotelId?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programHotelMakkah"]>

  export type ProgramHotelMakkahSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    hotelId?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["programHotelMakkah"]>

  export type ProgramHotelMakkahSelectScalar = {
    id?: boolean
    programId?: boolean
    hotelId?: boolean
  }

  export type ProgramHotelMakkahInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }
  export type ProgramHotelMakkahIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $ProgramHotelMakkahPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProgramHotelMakkah"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      hotel: Prisma.$HotelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      programId: number
      hotelId: number
    }, ExtArgs["result"]["programHotelMakkah"]>
    composites: {}
  }

  type ProgramHotelMakkahGetPayload<S extends boolean | null | undefined | ProgramHotelMakkahDefaultArgs> = $Result.GetResult<Prisma.$ProgramHotelMakkahPayload, S>

  type ProgramHotelMakkahCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProgramHotelMakkahFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProgramHotelMakkahCountAggregateInputType | true
    }

  export interface ProgramHotelMakkahDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProgramHotelMakkah'], meta: { name: 'ProgramHotelMakkah' } }
    /**
     * Find zero or one ProgramHotelMakkah that matches the filter.
     * @param {ProgramHotelMakkahFindUniqueArgs} args - Arguments to find a ProgramHotelMakkah
     * @example
     * // Get one ProgramHotelMakkah
     * const programHotelMakkah = await prisma.programHotelMakkah.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProgramHotelMakkahFindUniqueArgs>(args: SelectSubset<T, ProgramHotelMakkahFindUniqueArgs<ExtArgs>>): Prisma__ProgramHotelMakkahClient<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ProgramHotelMakkah that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProgramHotelMakkahFindUniqueOrThrowArgs} args - Arguments to find a ProgramHotelMakkah
     * @example
     * // Get one ProgramHotelMakkah
     * const programHotelMakkah = await prisma.programHotelMakkah.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProgramHotelMakkahFindUniqueOrThrowArgs>(args: SelectSubset<T, ProgramHotelMakkahFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProgramHotelMakkahClient<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ProgramHotelMakkah that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMakkahFindFirstArgs} args - Arguments to find a ProgramHotelMakkah
     * @example
     * // Get one ProgramHotelMakkah
     * const programHotelMakkah = await prisma.programHotelMakkah.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProgramHotelMakkahFindFirstArgs>(args?: SelectSubset<T, ProgramHotelMakkahFindFirstArgs<ExtArgs>>): Prisma__ProgramHotelMakkahClient<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ProgramHotelMakkah that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMakkahFindFirstOrThrowArgs} args - Arguments to find a ProgramHotelMakkah
     * @example
     * // Get one ProgramHotelMakkah
     * const programHotelMakkah = await prisma.programHotelMakkah.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProgramHotelMakkahFindFirstOrThrowArgs>(args?: SelectSubset<T, ProgramHotelMakkahFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProgramHotelMakkahClient<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ProgramHotelMakkahs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMakkahFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProgramHotelMakkahs
     * const programHotelMakkahs = await prisma.programHotelMakkah.findMany()
     * 
     * // Get first 10 ProgramHotelMakkahs
     * const programHotelMakkahs = await prisma.programHotelMakkah.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const programHotelMakkahWithIdOnly = await prisma.programHotelMakkah.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProgramHotelMakkahFindManyArgs>(args?: SelectSubset<T, ProgramHotelMakkahFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ProgramHotelMakkah.
     * @param {ProgramHotelMakkahCreateArgs} args - Arguments to create a ProgramHotelMakkah.
     * @example
     * // Create one ProgramHotelMakkah
     * const ProgramHotelMakkah = await prisma.programHotelMakkah.create({
     *   data: {
     *     // ... data to create a ProgramHotelMakkah
     *   }
     * })
     * 
     */
    create<T extends ProgramHotelMakkahCreateArgs>(args: SelectSubset<T, ProgramHotelMakkahCreateArgs<ExtArgs>>): Prisma__ProgramHotelMakkahClient<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ProgramHotelMakkahs.
     * @param {ProgramHotelMakkahCreateManyArgs} args - Arguments to create many ProgramHotelMakkahs.
     * @example
     * // Create many ProgramHotelMakkahs
     * const programHotelMakkah = await prisma.programHotelMakkah.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProgramHotelMakkahCreateManyArgs>(args?: SelectSubset<T, ProgramHotelMakkahCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProgramHotelMakkahs and returns the data saved in the database.
     * @param {ProgramHotelMakkahCreateManyAndReturnArgs} args - Arguments to create many ProgramHotelMakkahs.
     * @example
     * // Create many ProgramHotelMakkahs
     * const programHotelMakkah = await prisma.programHotelMakkah.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProgramHotelMakkahs and only return the `id`
     * const programHotelMakkahWithIdOnly = await prisma.programHotelMakkah.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProgramHotelMakkahCreateManyAndReturnArgs>(args?: SelectSubset<T, ProgramHotelMakkahCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ProgramHotelMakkah.
     * @param {ProgramHotelMakkahDeleteArgs} args - Arguments to delete one ProgramHotelMakkah.
     * @example
     * // Delete one ProgramHotelMakkah
     * const ProgramHotelMakkah = await prisma.programHotelMakkah.delete({
     *   where: {
     *     // ... filter to delete one ProgramHotelMakkah
     *   }
     * })
     * 
     */
    delete<T extends ProgramHotelMakkahDeleteArgs>(args: SelectSubset<T, ProgramHotelMakkahDeleteArgs<ExtArgs>>): Prisma__ProgramHotelMakkahClient<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ProgramHotelMakkah.
     * @param {ProgramHotelMakkahUpdateArgs} args - Arguments to update one ProgramHotelMakkah.
     * @example
     * // Update one ProgramHotelMakkah
     * const programHotelMakkah = await prisma.programHotelMakkah.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProgramHotelMakkahUpdateArgs>(args: SelectSubset<T, ProgramHotelMakkahUpdateArgs<ExtArgs>>): Prisma__ProgramHotelMakkahClient<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ProgramHotelMakkahs.
     * @param {ProgramHotelMakkahDeleteManyArgs} args - Arguments to filter ProgramHotelMakkahs to delete.
     * @example
     * // Delete a few ProgramHotelMakkahs
     * const { count } = await prisma.programHotelMakkah.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProgramHotelMakkahDeleteManyArgs>(args?: SelectSubset<T, ProgramHotelMakkahDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProgramHotelMakkahs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMakkahUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProgramHotelMakkahs
     * const programHotelMakkah = await prisma.programHotelMakkah.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProgramHotelMakkahUpdateManyArgs>(args: SelectSubset<T, ProgramHotelMakkahUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ProgramHotelMakkah.
     * @param {ProgramHotelMakkahUpsertArgs} args - Arguments to update or create a ProgramHotelMakkah.
     * @example
     * // Update or create a ProgramHotelMakkah
     * const programHotelMakkah = await prisma.programHotelMakkah.upsert({
     *   create: {
     *     // ... data to create a ProgramHotelMakkah
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProgramHotelMakkah we want to update
     *   }
     * })
     */
    upsert<T extends ProgramHotelMakkahUpsertArgs>(args: SelectSubset<T, ProgramHotelMakkahUpsertArgs<ExtArgs>>): Prisma__ProgramHotelMakkahClient<$Result.GetResult<Prisma.$ProgramHotelMakkahPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ProgramHotelMakkahs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMakkahCountArgs} args - Arguments to filter ProgramHotelMakkahs to count.
     * @example
     * // Count the number of ProgramHotelMakkahs
     * const count = await prisma.programHotelMakkah.count({
     *   where: {
     *     // ... the filter for the ProgramHotelMakkahs we want to count
     *   }
     * })
    **/
    count<T extends ProgramHotelMakkahCountArgs>(
      args?: Subset<T, ProgramHotelMakkahCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProgramHotelMakkahCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProgramHotelMakkah.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMakkahAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProgramHotelMakkahAggregateArgs>(args: Subset<T, ProgramHotelMakkahAggregateArgs>): Prisma.PrismaPromise<GetProgramHotelMakkahAggregateType<T>>

    /**
     * Group by ProgramHotelMakkah.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProgramHotelMakkahGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProgramHotelMakkahGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProgramHotelMakkahGroupByArgs['orderBy'] }
        : { orderBy?: ProgramHotelMakkahGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProgramHotelMakkahGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProgramHotelMakkahGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProgramHotelMakkah model
   */
  readonly fields: ProgramHotelMakkahFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProgramHotelMakkah.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProgramHotelMakkahClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProgramHotelMakkah model
   */ 
  interface ProgramHotelMakkahFieldRefs {
    readonly id: FieldRef<"ProgramHotelMakkah", 'Int'>
    readonly programId: FieldRef<"ProgramHotelMakkah", 'Int'>
    readonly hotelId: FieldRef<"ProgramHotelMakkah", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * ProgramHotelMakkah findUnique
   */
  export type ProgramHotelMakkahFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMakkah to fetch.
     */
    where: ProgramHotelMakkahWhereUniqueInput
  }

  /**
   * ProgramHotelMakkah findUniqueOrThrow
   */
  export type ProgramHotelMakkahFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMakkah to fetch.
     */
    where: ProgramHotelMakkahWhereUniqueInput
  }

  /**
   * ProgramHotelMakkah findFirst
   */
  export type ProgramHotelMakkahFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMakkah to fetch.
     */
    where?: ProgramHotelMakkahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramHotelMakkahs to fetch.
     */
    orderBy?: ProgramHotelMakkahOrderByWithRelationInput | ProgramHotelMakkahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramHotelMakkahs.
     */
    cursor?: ProgramHotelMakkahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramHotelMakkahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramHotelMakkahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramHotelMakkahs.
     */
    distinct?: ProgramHotelMakkahScalarFieldEnum | ProgramHotelMakkahScalarFieldEnum[]
  }

  /**
   * ProgramHotelMakkah findFirstOrThrow
   */
  export type ProgramHotelMakkahFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMakkah to fetch.
     */
    where?: ProgramHotelMakkahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramHotelMakkahs to fetch.
     */
    orderBy?: ProgramHotelMakkahOrderByWithRelationInput | ProgramHotelMakkahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProgramHotelMakkahs.
     */
    cursor?: ProgramHotelMakkahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramHotelMakkahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramHotelMakkahs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProgramHotelMakkahs.
     */
    distinct?: ProgramHotelMakkahScalarFieldEnum | ProgramHotelMakkahScalarFieldEnum[]
  }

  /**
   * ProgramHotelMakkah findMany
   */
  export type ProgramHotelMakkahFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    /**
     * Filter, which ProgramHotelMakkahs to fetch.
     */
    where?: ProgramHotelMakkahWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProgramHotelMakkahs to fetch.
     */
    orderBy?: ProgramHotelMakkahOrderByWithRelationInput | ProgramHotelMakkahOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProgramHotelMakkahs.
     */
    cursor?: ProgramHotelMakkahWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProgramHotelMakkahs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProgramHotelMakkahs.
     */
    skip?: number
    distinct?: ProgramHotelMakkahScalarFieldEnum | ProgramHotelMakkahScalarFieldEnum[]
  }

  /**
   * ProgramHotelMakkah create
   */
  export type ProgramHotelMakkahCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    /**
     * The data needed to create a ProgramHotelMakkah.
     */
    data: XOR<ProgramHotelMakkahCreateInput, ProgramHotelMakkahUncheckedCreateInput>
  }

  /**
   * ProgramHotelMakkah createMany
   */
  export type ProgramHotelMakkahCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProgramHotelMakkahs.
     */
    data: ProgramHotelMakkahCreateManyInput | ProgramHotelMakkahCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProgramHotelMakkah createManyAndReturn
   */
  export type ProgramHotelMakkahCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ProgramHotelMakkahs.
     */
    data: ProgramHotelMakkahCreateManyInput | ProgramHotelMakkahCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProgramHotelMakkah update
   */
  export type ProgramHotelMakkahUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    /**
     * The data needed to update a ProgramHotelMakkah.
     */
    data: XOR<ProgramHotelMakkahUpdateInput, ProgramHotelMakkahUncheckedUpdateInput>
    /**
     * Choose, which ProgramHotelMakkah to update.
     */
    where: ProgramHotelMakkahWhereUniqueInput
  }

  /**
   * ProgramHotelMakkah updateMany
   */
  export type ProgramHotelMakkahUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProgramHotelMakkahs.
     */
    data: XOR<ProgramHotelMakkahUpdateManyMutationInput, ProgramHotelMakkahUncheckedUpdateManyInput>
    /**
     * Filter which ProgramHotelMakkahs to update
     */
    where?: ProgramHotelMakkahWhereInput
  }

  /**
   * ProgramHotelMakkah upsert
   */
  export type ProgramHotelMakkahUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    /**
     * The filter to search for the ProgramHotelMakkah to update in case it exists.
     */
    where: ProgramHotelMakkahWhereUniqueInput
    /**
     * In case the ProgramHotelMakkah found by the `where` argument doesn't exist, create a new ProgramHotelMakkah with this data.
     */
    create: XOR<ProgramHotelMakkahCreateInput, ProgramHotelMakkahUncheckedCreateInput>
    /**
     * In case the ProgramHotelMakkah was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProgramHotelMakkahUpdateInput, ProgramHotelMakkahUncheckedUpdateInput>
  }

  /**
   * ProgramHotelMakkah delete
   */
  export type ProgramHotelMakkahDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
    /**
     * Filter which ProgramHotelMakkah to delete.
     */
    where: ProgramHotelMakkahWhereUniqueInput
  }

  /**
   * ProgramHotelMakkah deleteMany
   */
  export type ProgramHotelMakkahDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProgramHotelMakkahs to delete
     */
    where?: ProgramHotelMakkahWhereInput
  }

  /**
   * ProgramHotelMakkah without action
   */
  export type ProgramHotelMakkahDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProgramHotelMakkah
     */
    select?: ProgramHotelMakkahSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramHotelMakkahInclude<ExtArgs> | null
  }


  /**
   * Model Room
   */

  export type AggregateRoom = {
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  export type RoomAvgAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
    nbrPlaceTotal: number | null
    nbrPlaceRestantes: number | null
    prixRoom: number | null
    listeIdsReservation: number | null
  }

  export type RoomSumAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
    nbrPlaceTotal: number | null
    nbrPlaceRestantes: number | null
    prixRoom: number | null
    listeIdsReservation: number[]
  }

  export type RoomMinAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
    roomType: $Enums.RoomType | null
    gender: string | null
    nbrPlaceTotal: number | null
    nbrPlaceRestantes: number | null
    prixRoom: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RoomMaxAggregateOutputType = {
    id: number | null
    programId: number | null
    hotelId: number | null
    roomType: $Enums.RoomType | null
    gender: string | null
    nbrPlaceTotal: number | null
    nbrPlaceRestantes: number | null
    prixRoom: number | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type RoomCountAggregateOutputType = {
    id: number
    programId: number
    hotelId: number
    roomType: number
    gender: number
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type RoomAvgAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
    nbrPlaceTotal?: true
    nbrPlaceRestantes?: true
    prixRoom?: true
    listeIdsReservation?: true
  }

  export type RoomSumAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
    nbrPlaceTotal?: true
    nbrPlaceRestantes?: true
    prixRoom?: true
    listeIdsReservation?: true
  }

  export type RoomMinAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
    roomType?: true
    gender?: true
    nbrPlaceTotal?: true
    nbrPlaceRestantes?: true
    prixRoom?: true
    created_at?: true
    updated_at?: true
  }

  export type RoomMaxAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
    roomType?: true
    gender?: true
    nbrPlaceTotal?: true
    nbrPlaceRestantes?: true
    prixRoom?: true
    created_at?: true
    updated_at?: true
  }

  export type RoomCountAggregateInputType = {
    id?: true
    programId?: true
    hotelId?: true
    roomType?: true
    gender?: true
    nbrPlaceTotal?: true
    nbrPlaceRestantes?: true
    prixRoom?: true
    listeIdsReservation?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type RoomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Room to aggregate.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Rooms
    **/
    _count?: true | RoomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoomMaxAggregateInputType
  }

  export type GetRoomAggregateType<T extends RoomAggregateArgs> = {
        [P in keyof T & keyof AggregateRoom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoom[P]>
      : GetScalarType<T[P], AggregateRoom[P]>
  }




  export type RoomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoomWhereInput
    orderBy?: RoomOrderByWithAggregationInput | RoomOrderByWithAggregationInput[]
    by: RoomScalarFieldEnum[] | RoomScalarFieldEnum
    having?: RoomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoomCountAggregateInputType | true
    _avg?: RoomAvgAggregateInputType
    _sum?: RoomSumAggregateInputType
    _min?: RoomMinAggregateInputType
    _max?: RoomMaxAggregateInputType
  }

  export type RoomGroupByOutputType = {
    id: number
    programId: number
    hotelId: number
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation: number[]
    created_at: Date
    updated_at: Date
    _count: RoomCountAggregateOutputType | null
    _avg: RoomAvgAggregateOutputType | null
    _sum: RoomSumAggregateOutputType | null
    _min: RoomMinAggregateOutputType | null
    _max: RoomMaxAggregateOutputType | null
  }

  type GetRoomGroupByPayload<T extends RoomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoomGroupByOutputType[P]>
            : GetScalarType<T[P], RoomGroupByOutputType[P]>
        }
      >
    >


  export type RoomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    hotelId?: boolean
    roomType?: boolean
    gender?: boolean
    nbrPlaceTotal?: boolean
    nbrPlaceRestantes?: boolean
    prixRoom?: boolean
    listeIdsReservation?: boolean
    created_at?: boolean
    updated_at?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    programId?: boolean
    hotelId?: boolean
    roomType?: boolean
    gender?: boolean
    nbrPlaceTotal?: boolean
    nbrPlaceRestantes?: boolean
    prixRoom?: boolean
    listeIdsReservation?: boolean
    created_at?: boolean
    updated_at?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["room"]>

  export type RoomSelectScalar = {
    id?: boolean
    programId?: boolean
    hotelId?: boolean
    roomType?: boolean
    gender?: boolean
    nbrPlaceTotal?: boolean
    nbrPlaceRestantes?: boolean
    prixRoom?: boolean
    listeIdsReservation?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type RoomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }
  export type RoomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    hotel?: boolean | HotelDefaultArgs<ExtArgs>
  }

  export type $RoomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Room"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs>
      hotel: Prisma.$HotelPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      programId: number
      hotelId: number
      roomType: $Enums.RoomType
      gender: string
      nbrPlaceTotal: number
      nbrPlaceRestantes: number
      prixRoom: number
      listeIdsReservation: number[]
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["room"]>
    composites: {}
  }

  type RoomGetPayload<S extends boolean | null | undefined | RoomDefaultArgs> = $Result.GetResult<Prisma.$RoomPayload, S>

  type RoomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoomFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoomCountAggregateInputType | true
    }

  export interface RoomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Room'], meta: { name: 'Room' } }
    /**
     * Find zero or one Room that matches the filter.
     * @param {RoomFindUniqueArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoomFindUniqueArgs>(args: SelectSubset<T, RoomFindUniqueArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Room that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoomFindUniqueOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoomFindUniqueOrThrowArgs>(args: SelectSubset<T, RoomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Room that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoomFindFirstArgs>(args?: SelectSubset<T, RoomFindFirstArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Room that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindFirstOrThrowArgs} args - Arguments to find a Room
     * @example
     * // Get one Room
     * const room = await prisma.room.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoomFindFirstOrThrowArgs>(args?: SelectSubset<T, RoomFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Rooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Rooms
     * const rooms = await prisma.room.findMany()
     * 
     * // Get first 10 Rooms
     * const rooms = await prisma.room.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roomWithIdOnly = await prisma.room.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoomFindManyArgs>(args?: SelectSubset<T, RoomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Room.
     * @param {RoomCreateArgs} args - Arguments to create a Room.
     * @example
     * // Create one Room
     * const Room = await prisma.room.create({
     *   data: {
     *     // ... data to create a Room
     *   }
     * })
     * 
     */
    create<T extends RoomCreateArgs>(args: SelectSubset<T, RoomCreateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Rooms.
     * @param {RoomCreateManyArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoomCreateManyArgs>(args?: SelectSubset<T, RoomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Rooms and returns the data saved in the database.
     * @param {RoomCreateManyAndReturnArgs} args - Arguments to create many Rooms.
     * @example
     * // Create many Rooms
     * const room = await prisma.room.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Rooms and only return the `id`
     * const roomWithIdOnly = await prisma.room.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RoomCreateManyAndReturnArgs>(args?: SelectSubset<T, RoomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Room.
     * @param {RoomDeleteArgs} args - Arguments to delete one Room.
     * @example
     * // Delete one Room
     * const Room = await prisma.room.delete({
     *   where: {
     *     // ... filter to delete one Room
     *   }
     * })
     * 
     */
    delete<T extends RoomDeleteArgs>(args: SelectSubset<T, RoomDeleteArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Room.
     * @param {RoomUpdateArgs} args - Arguments to update one Room.
     * @example
     * // Update one Room
     * const room = await prisma.room.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoomUpdateArgs>(args: SelectSubset<T, RoomUpdateArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Rooms.
     * @param {RoomDeleteManyArgs} args - Arguments to filter Rooms to delete.
     * @example
     * // Delete a few Rooms
     * const { count } = await prisma.room.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoomDeleteManyArgs>(args?: SelectSubset<T, RoomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Rooms
     * const room = await prisma.room.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoomUpdateManyArgs>(args: SelectSubset<T, RoomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Room.
     * @param {RoomUpsertArgs} args - Arguments to update or create a Room.
     * @example
     * // Update or create a Room
     * const room = await prisma.room.upsert({
     *   create: {
     *     // ... data to create a Room
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Room we want to update
     *   }
     * })
     */
    upsert<T extends RoomUpsertArgs>(args: SelectSubset<T, RoomUpsertArgs<ExtArgs>>): Prisma__RoomClient<$Result.GetResult<Prisma.$RoomPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Rooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomCountArgs} args - Arguments to filter Rooms to count.
     * @example
     * // Count the number of Rooms
     * const count = await prisma.room.count({
     *   where: {
     *     // ... the filter for the Rooms we want to count
     *   }
     * })
    **/
    count<T extends RoomCountArgs>(
      args?: Subset<T, RoomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoomAggregateArgs>(args: Subset<T, RoomAggregateArgs>): Prisma.PrismaPromise<GetRoomAggregateType<T>>

    /**
     * Group by Room.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoomGroupByArgs['orderBy'] }
        : { orderBy?: RoomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Room model
   */
  readonly fields: RoomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Room.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    hotel<T extends HotelDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HotelDefaultArgs<ExtArgs>>): Prisma__HotelClient<$Result.GetResult<Prisma.$HotelPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Room model
   */ 
  interface RoomFieldRefs {
    readonly id: FieldRef<"Room", 'Int'>
    readonly programId: FieldRef<"Room", 'Int'>
    readonly hotelId: FieldRef<"Room", 'Int'>
    readonly roomType: FieldRef<"Room", 'RoomType'>
    readonly gender: FieldRef<"Room", 'String'>
    readonly nbrPlaceTotal: FieldRef<"Room", 'Int'>
    readonly nbrPlaceRestantes: FieldRef<"Room", 'Int'>
    readonly prixRoom: FieldRef<"Room", 'Float'>
    readonly listeIdsReservation: FieldRef<"Room", 'Int[]'>
    readonly created_at: FieldRef<"Room", 'DateTime'>
    readonly updated_at: FieldRef<"Room", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Room findUnique
   */
  export type RoomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findUniqueOrThrow
   */
  export type RoomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room findFirst
   */
  export type RoomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findFirstOrThrow
   */
  export type RoomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Room to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Rooms.
     */
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room findMany
   */
  export type RoomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter, which Rooms to fetch.
     */
    where?: RoomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Rooms to fetch.
     */
    orderBy?: RoomOrderByWithRelationInput | RoomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Rooms.
     */
    cursor?: RoomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Rooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Rooms.
     */
    skip?: number
    distinct?: RoomScalarFieldEnum | RoomScalarFieldEnum[]
  }

  /**
   * Room create
   */
  export type RoomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to create a Room.
     */
    data: XOR<RoomCreateInput, RoomUncheckedCreateInput>
  }

  /**
   * Room createMany
   */
  export type RoomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Room createManyAndReturn
   */
  export type RoomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Rooms.
     */
    data: RoomCreateManyInput | RoomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Room update
   */
  export type RoomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The data needed to update a Room.
     */
    data: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
    /**
     * Choose, which Room to update.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room updateMany
   */
  export type RoomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Rooms.
     */
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyInput>
    /**
     * Filter which Rooms to update
     */
    where?: RoomWhereInput
  }

  /**
   * Room upsert
   */
  export type RoomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * The filter to search for the Room to update in case it exists.
     */
    where: RoomWhereUniqueInput
    /**
     * In case the Room found by the `where` argument doesn't exist, create a new Room with this data.
     */
    create: XOR<RoomCreateInput, RoomUncheckedCreateInput>
    /**
     * In case the Room was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoomUpdateInput, RoomUncheckedUpdateInput>
  }

  /**
   * Room delete
   */
  export type RoomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
    /**
     * Filter which Room to delete.
     */
    where: RoomWhereUniqueInput
  }

  /**
   * Room deleteMany
   */
  export type RoomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Rooms to delete
     */
    where?: RoomWhereInput
  }

  /**
   * Room without action
   */
  export type RoomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Room
     */
    select?: RoomSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoomInclude<ExtArgs> | null
  }


  /**
   * Model Reservation
   */

  export type AggregateReservation = {
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  export type ReservationAvgAggregateOutputType = {
    id: number | null
    programId: number | null
    price: number | null
    reduction: number | null
    paidAmount: number | null
    agentId: number | null
  }

  export type ReservationSumAggregateOutputType = {
    id: number | null
    programId: number | null
    price: number | null
    reduction: number | null
    paidAmount: number | null
    agentId: number | null
  }

  export type ReservationMinAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    programId: number | null
    roomType: $Enums.RoomType | null
    gender: string | null
    hotelMadina: string | null
    hotelMakkah: string | null
    price: number | null
    reduction: number | null
    paidAmount: number | null
    status: string | null
    statutPasseport: boolean | null
    statutVisa: boolean | null
    statutHotel: boolean | null
    statutVol: boolean | null
    reservationDate: Date | null
    created_at: Date | null
    updated_at: Date | null
    agentId: number | null
  }

  export type ReservationMaxAggregateOutputType = {
    id: number | null
    firstName: string | null
    lastName: string | null
    phone: string | null
    programId: number | null
    roomType: $Enums.RoomType | null
    gender: string | null
    hotelMadina: string | null
    hotelMakkah: string | null
    price: number | null
    reduction: number | null
    paidAmount: number | null
    status: string | null
    statutPasseport: boolean | null
    statutVisa: boolean | null
    statutHotel: boolean | null
    statutVol: boolean | null
    reservationDate: Date | null
    created_at: Date | null
    updated_at: Date | null
    agentId: number | null
  }

  export type ReservationCountAggregateOutputType = {
    id: number
    firstName: number
    lastName: number
    phone: number
    programId: number
    roomType: number
    gender: number
    hotelMadina: number
    hotelMakkah: number
    price: number
    reduction: number
    paidAmount: number
    status: number
    statutPasseport: number
    statutVisa: number
    statutHotel: number
    statutVol: number
    reservationDate: number
    created_at: number
    updated_at: number
    agentId: number
    _all: number
  }


  export type ReservationAvgAggregateInputType = {
    id?: true
    programId?: true
    price?: true
    reduction?: true
    paidAmount?: true
    agentId?: true
  }

  export type ReservationSumAggregateInputType = {
    id?: true
    programId?: true
    price?: true
    reduction?: true
    paidAmount?: true
    agentId?: true
  }

  export type ReservationMinAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    programId?: true
    roomType?: true
    gender?: true
    hotelMadina?: true
    hotelMakkah?: true
    price?: true
    reduction?: true
    paidAmount?: true
    status?: true
    statutPasseport?: true
    statutVisa?: true
    statutHotel?: true
    statutVol?: true
    reservationDate?: true
    created_at?: true
    updated_at?: true
    agentId?: true
  }

  export type ReservationMaxAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    programId?: true
    roomType?: true
    gender?: true
    hotelMadina?: true
    hotelMakkah?: true
    price?: true
    reduction?: true
    paidAmount?: true
    status?: true
    statutPasseport?: true
    statutVisa?: true
    statutHotel?: true
    statutVol?: true
    reservationDate?: true
    created_at?: true
    updated_at?: true
    agentId?: true
  }

  export type ReservationCountAggregateInputType = {
    id?: true
    firstName?: true
    lastName?: true
    phone?: true
    programId?: true
    roomType?: true
    gender?: true
    hotelMadina?: true
    hotelMakkah?: true
    price?: true
    reduction?: true
    paidAmount?: true
    status?: true
    statutPasseport?: true
    statutVisa?: true
    statutHotel?: true
    statutVol?: true
    reservationDate?: true
    created_at?: true
    updated_at?: true
    agentId?: true
    _all?: true
  }

  export type ReservationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservation to aggregate.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Reservations
    **/
    _count?: true | ReservationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReservationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReservationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReservationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReservationMaxAggregateInputType
  }

  export type GetReservationAggregateType<T extends ReservationAggregateArgs> = {
        [P in keyof T & keyof AggregateReservation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReservation[P]>
      : GetScalarType<T[P], AggregateReservation[P]>
  }




  export type ReservationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ReservationWhereInput
    orderBy?: ReservationOrderByWithAggregationInput | ReservationOrderByWithAggregationInput[]
    by: ReservationScalarFieldEnum[] | ReservationScalarFieldEnum
    having?: ReservationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReservationCountAggregateInputType | true
    _avg?: ReservationAvgAggregateInputType
    _sum?: ReservationSumAggregateInputType
    _min?: ReservationMinAggregateInputType
    _max?: ReservationMaxAggregateInputType
  }

  export type ReservationGroupByOutputType = {
    id: number
    firstName: string
    lastName: string
    phone: string
    programId: number
    roomType: $Enums.RoomType
    gender: string
    hotelMadina: string | null
    hotelMakkah: string | null
    price: number
    reduction: number
    paidAmount: number
    status: string
    statutPasseport: boolean
    statutVisa: boolean
    statutHotel: boolean
    statutVol: boolean
    reservationDate: Date
    created_at: Date
    updated_at: Date
    agentId: number | null
    _count: ReservationCountAggregateOutputType | null
    _avg: ReservationAvgAggregateOutputType | null
    _sum: ReservationSumAggregateOutputType | null
    _min: ReservationMinAggregateOutputType | null
    _max: ReservationMaxAggregateOutputType | null
  }

  type GetReservationGroupByPayload<T extends ReservationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ReservationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReservationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReservationGroupByOutputType[P]>
            : GetScalarType<T[P], ReservationGroupByOutputType[P]>
        }
      >
    >


  export type ReservationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    programId?: boolean
    roomType?: boolean
    gender?: boolean
    hotelMadina?: boolean
    hotelMakkah?: boolean
    price?: boolean
    reduction?: boolean
    paidAmount?: boolean
    status?: boolean
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate?: boolean
    created_at?: boolean
    updated_at?: boolean
    agentId?: boolean
    documents?: boolean | Reservation$documentsArgs<ExtArgs>
    payments?: boolean | Reservation$paymentsArgs<ExtArgs>
    expenses?: boolean | Reservation$expensesArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    agent?: boolean | Reservation$agentArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    programId?: boolean
    roomType?: boolean
    gender?: boolean
    hotelMadina?: boolean
    hotelMakkah?: boolean
    price?: boolean
    reduction?: boolean
    paidAmount?: boolean
    status?: boolean
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate?: boolean
    created_at?: boolean
    updated_at?: boolean
    agentId?: boolean
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    agent?: boolean | Reservation$agentArgs<ExtArgs>
  }, ExtArgs["result"]["reservation"]>

  export type ReservationSelectScalar = {
    id?: boolean
    firstName?: boolean
    lastName?: boolean
    phone?: boolean
    programId?: boolean
    roomType?: boolean
    gender?: boolean
    hotelMadina?: boolean
    hotelMakkah?: boolean
    price?: boolean
    reduction?: boolean
    paidAmount?: boolean
    status?: boolean
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate?: boolean
    created_at?: boolean
    updated_at?: boolean
    agentId?: boolean
  }

  export type ReservationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documents?: boolean | Reservation$documentsArgs<ExtArgs>
    payments?: boolean | Reservation$paymentsArgs<ExtArgs>
    expenses?: boolean | Reservation$expensesArgs<ExtArgs>
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    agent?: boolean | Reservation$agentArgs<ExtArgs>
    _count?: boolean | ReservationCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ReservationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | ProgramDefaultArgs<ExtArgs>
    agent?: boolean | Reservation$agentArgs<ExtArgs>
  }

  export type $ReservationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Reservation"
    objects: {
      documents: Prisma.$FichierPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
      program: Prisma.$ProgramPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      firstName: string
      lastName: string
      phone: string
      programId: number
      roomType: $Enums.RoomType
      gender: string
      hotelMadina: string | null
      hotelMakkah: string | null
      price: number
      reduction: number
      paidAmount: number
      status: string
      statutPasseport: boolean
      statutVisa: boolean
      statutHotel: boolean
      statutVol: boolean
      reservationDate: Date
      created_at: Date
      updated_at: Date
      agentId: number | null
    }, ExtArgs["result"]["reservation"]>
    composites: {}
  }

  type ReservationGetPayload<S extends boolean | null | undefined | ReservationDefaultArgs> = $Result.GetResult<Prisma.$ReservationPayload, S>

  type ReservationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ReservationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ReservationCountAggregateInputType | true
    }

  export interface ReservationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Reservation'], meta: { name: 'Reservation' } }
    /**
     * Find zero or one Reservation that matches the filter.
     * @param {ReservationFindUniqueArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ReservationFindUniqueArgs>(args: SelectSubset<T, ReservationFindUniqueArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Reservation that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ReservationFindUniqueOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ReservationFindUniqueOrThrowArgs>(args: SelectSubset<T, ReservationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Reservation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ReservationFindFirstArgs>(args?: SelectSubset<T, ReservationFindFirstArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Reservation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindFirstOrThrowArgs} args - Arguments to find a Reservation
     * @example
     * // Get one Reservation
     * const reservation = await prisma.reservation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ReservationFindFirstOrThrowArgs>(args?: SelectSubset<T, ReservationFindFirstOrThrowArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Reservations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reservations
     * const reservations = await prisma.reservation.findMany()
     * 
     * // Get first 10 Reservations
     * const reservations = await prisma.reservation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reservationWithIdOnly = await prisma.reservation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ReservationFindManyArgs>(args?: SelectSubset<T, ReservationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Reservation.
     * @param {ReservationCreateArgs} args - Arguments to create a Reservation.
     * @example
     * // Create one Reservation
     * const Reservation = await prisma.reservation.create({
     *   data: {
     *     // ... data to create a Reservation
     *   }
     * })
     * 
     */
    create<T extends ReservationCreateArgs>(args: SelectSubset<T, ReservationCreateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Reservations.
     * @param {ReservationCreateManyArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ReservationCreateManyArgs>(args?: SelectSubset<T, ReservationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Reservations and returns the data saved in the database.
     * @param {ReservationCreateManyAndReturnArgs} args - Arguments to create many Reservations.
     * @example
     * // Create many Reservations
     * const reservation = await prisma.reservation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Reservations and only return the `id`
     * const reservationWithIdOnly = await prisma.reservation.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ReservationCreateManyAndReturnArgs>(args?: SelectSubset<T, ReservationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Reservation.
     * @param {ReservationDeleteArgs} args - Arguments to delete one Reservation.
     * @example
     * // Delete one Reservation
     * const Reservation = await prisma.reservation.delete({
     *   where: {
     *     // ... filter to delete one Reservation
     *   }
     * })
     * 
     */
    delete<T extends ReservationDeleteArgs>(args: SelectSubset<T, ReservationDeleteArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Reservation.
     * @param {ReservationUpdateArgs} args - Arguments to update one Reservation.
     * @example
     * // Update one Reservation
     * const reservation = await prisma.reservation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ReservationUpdateArgs>(args: SelectSubset<T, ReservationUpdateArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Reservations.
     * @param {ReservationDeleteManyArgs} args - Arguments to filter Reservations to delete.
     * @example
     * // Delete a few Reservations
     * const { count } = await prisma.reservation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ReservationDeleteManyArgs>(args?: SelectSubset<T, ReservationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reservations
     * const reservation = await prisma.reservation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ReservationUpdateManyArgs>(args: SelectSubset<T, ReservationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Reservation.
     * @param {ReservationUpsertArgs} args - Arguments to update or create a Reservation.
     * @example
     * // Update or create a Reservation
     * const reservation = await prisma.reservation.upsert({
     *   create: {
     *     // ... data to create a Reservation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Reservation we want to update
     *   }
     * })
     */
    upsert<T extends ReservationUpsertArgs>(args: SelectSubset<T, ReservationUpsertArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Reservations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationCountArgs} args - Arguments to filter Reservations to count.
     * @example
     * // Count the number of Reservations
     * const count = await prisma.reservation.count({
     *   where: {
     *     // ... the filter for the Reservations we want to count
     *   }
     * })
    **/
    count<T extends ReservationCountArgs>(
      args?: Subset<T, ReservationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReservationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReservationAggregateArgs>(args: Subset<T, ReservationAggregateArgs>): Prisma.PrismaPromise<GetReservationAggregateType<T>>

    /**
     * Group by Reservation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReservationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReservationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReservationGroupByArgs['orderBy'] }
        : { orderBy?: ReservationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReservationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReservationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Reservation model
   */
  readonly fields: ReservationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Reservation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ReservationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documents<T extends Reservation$documentsArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$documentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "findMany"> | Null>
    payments<T extends Reservation$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany"> | Null>
    expenses<T extends Reservation$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    program<T extends ProgramDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProgramDefaultArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    agent<T extends Reservation$agentArgs<ExtArgs> = {}>(args?: Subset<T, Reservation$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Reservation model
   */ 
  interface ReservationFieldRefs {
    readonly id: FieldRef<"Reservation", 'Int'>
    readonly firstName: FieldRef<"Reservation", 'String'>
    readonly lastName: FieldRef<"Reservation", 'String'>
    readonly phone: FieldRef<"Reservation", 'String'>
    readonly programId: FieldRef<"Reservation", 'Int'>
    readonly roomType: FieldRef<"Reservation", 'RoomType'>
    readonly gender: FieldRef<"Reservation", 'String'>
    readonly hotelMadina: FieldRef<"Reservation", 'String'>
    readonly hotelMakkah: FieldRef<"Reservation", 'String'>
    readonly price: FieldRef<"Reservation", 'Float'>
    readonly reduction: FieldRef<"Reservation", 'Float'>
    readonly paidAmount: FieldRef<"Reservation", 'Float'>
    readonly status: FieldRef<"Reservation", 'String'>
    readonly statutPasseport: FieldRef<"Reservation", 'Boolean'>
    readonly statutVisa: FieldRef<"Reservation", 'Boolean'>
    readonly statutHotel: FieldRef<"Reservation", 'Boolean'>
    readonly statutVol: FieldRef<"Reservation", 'Boolean'>
    readonly reservationDate: FieldRef<"Reservation", 'DateTime'>
    readonly created_at: FieldRef<"Reservation", 'DateTime'>
    readonly updated_at: FieldRef<"Reservation", 'DateTime'>
    readonly agentId: FieldRef<"Reservation", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Reservation findUnique
   */
  export type ReservationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findUniqueOrThrow
   */
  export type ReservationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation findFirst
   */
  export type ReservationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findFirstOrThrow
   */
  export type ReservationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservation to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Reservations.
     */
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation findMany
   */
  export type ReservationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter, which Reservations to fetch.
     */
    where?: ReservationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Reservations to fetch.
     */
    orderBy?: ReservationOrderByWithRelationInput | ReservationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Reservations.
     */
    cursor?: ReservationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Reservations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Reservations.
     */
    skip?: number
    distinct?: ReservationScalarFieldEnum | ReservationScalarFieldEnum[]
  }

  /**
   * Reservation create
   */
  export type ReservationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to create a Reservation.
     */
    data: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
  }

  /**
   * Reservation createMany
   */
  export type ReservationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Reservation createManyAndReturn
   */
  export type ReservationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Reservations.
     */
    data: ReservationCreateManyInput | ReservationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Reservation update
   */
  export type ReservationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The data needed to update a Reservation.
     */
    data: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
    /**
     * Choose, which Reservation to update.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation updateMany
   */
  export type ReservationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Reservations.
     */
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyInput>
    /**
     * Filter which Reservations to update
     */
    where?: ReservationWhereInput
  }

  /**
   * Reservation upsert
   */
  export type ReservationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * The filter to search for the Reservation to update in case it exists.
     */
    where: ReservationWhereUniqueInput
    /**
     * In case the Reservation found by the `where` argument doesn't exist, create a new Reservation with this data.
     */
    create: XOR<ReservationCreateInput, ReservationUncheckedCreateInput>
    /**
     * In case the Reservation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ReservationUpdateInput, ReservationUncheckedUpdateInput>
  }

  /**
   * Reservation delete
   */
  export type ReservationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    /**
     * Filter which Reservation to delete.
     */
    where: ReservationWhereUniqueInput
  }

  /**
   * Reservation deleteMany
   */
  export type ReservationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Reservations to delete
     */
    where?: ReservationWhereInput
  }

  /**
   * Reservation.documents
   */
  export type Reservation$documentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    where?: FichierWhereInput
    orderBy?: FichierOrderByWithRelationInput | FichierOrderByWithRelationInput[]
    cursor?: FichierWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FichierScalarFieldEnum | FichierScalarFieldEnum[]
  }

  /**
   * Reservation.payments
   */
  export type Reservation$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Reservation.expenses
   */
  export type Reservation$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Reservation.agent
   */
  export type Reservation$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Reservation without action
   */
  export type ReservationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
  }


  /**
   * Model Fichier
   */

  export type AggregateFichier = {
    _count: FichierCountAggregateOutputType | null
    _avg: FichierAvgAggregateOutputType | null
    _sum: FichierSumAggregateOutputType | null
    _min: FichierMinAggregateOutputType | null
    _max: FichierMaxAggregateOutputType | null
  }

  export type FichierAvgAggregateOutputType = {
    id: number | null
    reservationId: number | null
  }

  export type FichierSumAggregateOutputType = {
    id: number | null
    reservationId: number | null
  }

  export type FichierMinAggregateOutputType = {
    id: number | null
    reservationId: number | null
    fileName: string | null
    storedName: string | null
    fileType: string | null
    fileCategory: string | null
    filePath: string | null
    uploaded_at: Date | null
  }

  export type FichierMaxAggregateOutputType = {
    id: number | null
    reservationId: number | null
    fileName: string | null
    storedName: string | null
    fileType: string | null
    fileCategory: string | null
    filePath: string | null
    uploaded_at: Date | null
  }

  export type FichierCountAggregateOutputType = {
    id: number
    reservationId: number
    fileName: number
    storedName: number
    fileType: number
    fileCategory: number
    filePath: number
    uploaded_at: number
    _all: number
  }


  export type FichierAvgAggregateInputType = {
    id?: true
    reservationId?: true
  }

  export type FichierSumAggregateInputType = {
    id?: true
    reservationId?: true
  }

  export type FichierMinAggregateInputType = {
    id?: true
    reservationId?: true
    fileName?: true
    storedName?: true
    fileType?: true
    fileCategory?: true
    filePath?: true
    uploaded_at?: true
  }

  export type FichierMaxAggregateInputType = {
    id?: true
    reservationId?: true
    fileName?: true
    storedName?: true
    fileType?: true
    fileCategory?: true
    filePath?: true
    uploaded_at?: true
  }

  export type FichierCountAggregateInputType = {
    id?: true
    reservationId?: true
    fileName?: true
    storedName?: true
    fileType?: true
    fileCategory?: true
    filePath?: true
    uploaded_at?: true
    _all?: true
  }

  export type FichierAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fichier to aggregate.
     */
    where?: FichierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fichiers to fetch.
     */
    orderBy?: FichierOrderByWithRelationInput | FichierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FichierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fichiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fichiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Fichiers
    **/
    _count?: true | FichierCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FichierAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FichierSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FichierMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FichierMaxAggregateInputType
  }

  export type GetFichierAggregateType<T extends FichierAggregateArgs> = {
        [P in keyof T & keyof AggregateFichier]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFichier[P]>
      : GetScalarType<T[P], AggregateFichier[P]>
  }




  export type FichierGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FichierWhereInput
    orderBy?: FichierOrderByWithAggregationInput | FichierOrderByWithAggregationInput[]
    by: FichierScalarFieldEnum[] | FichierScalarFieldEnum
    having?: FichierScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FichierCountAggregateInputType | true
    _avg?: FichierAvgAggregateInputType
    _sum?: FichierSumAggregateInputType
    _min?: FichierMinAggregateInputType
    _max?: FichierMaxAggregateInputType
  }

  export type FichierGroupByOutputType = {
    id: number
    reservationId: number
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at: Date
    _count: FichierCountAggregateOutputType | null
    _avg: FichierAvgAggregateOutputType | null
    _sum: FichierSumAggregateOutputType | null
    _min: FichierMinAggregateOutputType | null
    _max: FichierMaxAggregateOutputType | null
  }

  type GetFichierGroupByPayload<T extends FichierGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FichierGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FichierGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FichierGroupByOutputType[P]>
            : GetScalarType<T[P], FichierGroupByOutputType[P]>
        }
      >
    >


  export type FichierSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservationId?: boolean
    fileName?: boolean
    storedName?: boolean
    fileType?: boolean
    fileCategory?: boolean
    filePath?: boolean
    uploaded_at?: boolean
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    payment?: boolean | Fichier$paymentArgs<ExtArgs>
    expenses?: boolean | Fichier$expensesArgs<ExtArgs>
    _count?: boolean | FichierCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fichier"]>

  export type FichierSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservationId?: boolean
    fileName?: boolean
    storedName?: boolean
    fileType?: boolean
    fileCategory?: boolean
    filePath?: boolean
    uploaded_at?: boolean
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["fichier"]>

  export type FichierSelectScalar = {
    id?: boolean
    reservationId?: boolean
    fileName?: boolean
    storedName?: boolean
    fileType?: boolean
    fileCategory?: boolean
    filePath?: boolean
    uploaded_at?: boolean
  }

  export type FichierInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    payment?: boolean | Fichier$paymentArgs<ExtArgs>
    expenses?: boolean | Fichier$expensesArgs<ExtArgs>
    _count?: boolean | FichierCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FichierIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
  }

  export type $FichierPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Fichier"
    objects: {
      reservation: Prisma.$ReservationPayload<ExtArgs>
      payment: Prisma.$PaymentPayload<ExtArgs> | null
      expenses: Prisma.$ExpensePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reservationId: number
      fileName: string
      storedName: string
      fileType: string
      fileCategory: string
      filePath: string
      uploaded_at: Date
    }, ExtArgs["result"]["fichier"]>
    composites: {}
  }

  type FichierGetPayload<S extends boolean | null | undefined | FichierDefaultArgs> = $Result.GetResult<Prisma.$FichierPayload, S>

  type FichierCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<FichierFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: FichierCountAggregateInputType | true
    }

  export interface FichierDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Fichier'], meta: { name: 'Fichier' } }
    /**
     * Find zero or one Fichier that matches the filter.
     * @param {FichierFindUniqueArgs} args - Arguments to find a Fichier
     * @example
     * // Get one Fichier
     * const fichier = await prisma.fichier.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FichierFindUniqueArgs>(args: SelectSubset<T, FichierFindUniqueArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Fichier that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {FichierFindUniqueOrThrowArgs} args - Arguments to find a Fichier
     * @example
     * // Get one Fichier
     * const fichier = await prisma.fichier.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FichierFindUniqueOrThrowArgs>(args: SelectSubset<T, FichierFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Fichier that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichierFindFirstArgs} args - Arguments to find a Fichier
     * @example
     * // Get one Fichier
     * const fichier = await prisma.fichier.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FichierFindFirstArgs>(args?: SelectSubset<T, FichierFindFirstArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Fichier that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichierFindFirstOrThrowArgs} args - Arguments to find a Fichier
     * @example
     * // Get one Fichier
     * const fichier = await prisma.fichier.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FichierFindFirstOrThrowArgs>(args?: SelectSubset<T, FichierFindFirstOrThrowArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Fichiers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichierFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Fichiers
     * const fichiers = await prisma.fichier.findMany()
     * 
     * // Get first 10 Fichiers
     * const fichiers = await prisma.fichier.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fichierWithIdOnly = await prisma.fichier.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FichierFindManyArgs>(args?: SelectSubset<T, FichierFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Fichier.
     * @param {FichierCreateArgs} args - Arguments to create a Fichier.
     * @example
     * // Create one Fichier
     * const Fichier = await prisma.fichier.create({
     *   data: {
     *     // ... data to create a Fichier
     *   }
     * })
     * 
     */
    create<T extends FichierCreateArgs>(args: SelectSubset<T, FichierCreateArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Fichiers.
     * @param {FichierCreateManyArgs} args - Arguments to create many Fichiers.
     * @example
     * // Create many Fichiers
     * const fichier = await prisma.fichier.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FichierCreateManyArgs>(args?: SelectSubset<T, FichierCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Fichiers and returns the data saved in the database.
     * @param {FichierCreateManyAndReturnArgs} args - Arguments to create many Fichiers.
     * @example
     * // Create many Fichiers
     * const fichier = await prisma.fichier.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Fichiers and only return the `id`
     * const fichierWithIdOnly = await prisma.fichier.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FichierCreateManyAndReturnArgs>(args?: SelectSubset<T, FichierCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Fichier.
     * @param {FichierDeleteArgs} args - Arguments to delete one Fichier.
     * @example
     * // Delete one Fichier
     * const Fichier = await prisma.fichier.delete({
     *   where: {
     *     // ... filter to delete one Fichier
     *   }
     * })
     * 
     */
    delete<T extends FichierDeleteArgs>(args: SelectSubset<T, FichierDeleteArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Fichier.
     * @param {FichierUpdateArgs} args - Arguments to update one Fichier.
     * @example
     * // Update one Fichier
     * const fichier = await prisma.fichier.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FichierUpdateArgs>(args: SelectSubset<T, FichierUpdateArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Fichiers.
     * @param {FichierDeleteManyArgs} args - Arguments to filter Fichiers to delete.
     * @example
     * // Delete a few Fichiers
     * const { count } = await prisma.fichier.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FichierDeleteManyArgs>(args?: SelectSubset<T, FichierDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Fichiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichierUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Fichiers
     * const fichier = await prisma.fichier.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FichierUpdateManyArgs>(args: SelectSubset<T, FichierUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Fichier.
     * @param {FichierUpsertArgs} args - Arguments to update or create a Fichier.
     * @example
     * // Update or create a Fichier
     * const fichier = await prisma.fichier.upsert({
     *   create: {
     *     // ... data to create a Fichier
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Fichier we want to update
     *   }
     * })
     */
    upsert<T extends FichierUpsertArgs>(args: SelectSubset<T, FichierUpsertArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Fichiers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichierCountArgs} args - Arguments to filter Fichiers to count.
     * @example
     * // Count the number of Fichiers
     * const count = await prisma.fichier.count({
     *   where: {
     *     // ... the filter for the Fichiers we want to count
     *   }
     * })
    **/
    count<T extends FichierCountArgs>(
      args?: Subset<T, FichierCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FichierCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Fichier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichierAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FichierAggregateArgs>(args: Subset<T, FichierAggregateArgs>): Prisma.PrismaPromise<GetFichierAggregateType<T>>

    /**
     * Group by Fichier.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FichierGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FichierGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FichierGroupByArgs['orderBy'] }
        : { orderBy?: FichierGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FichierGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFichierGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Fichier model
   */
  readonly fields: FichierFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Fichier.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FichierClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    reservation<T extends ReservationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReservationDefaultArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    payment<T extends Fichier$paymentArgs<ExtArgs> = {}>(args?: Subset<T, Fichier$paymentArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    expenses<T extends Fichier$expensesArgs<ExtArgs> = {}>(args?: Subset<T, Fichier$expensesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Fichier model
   */ 
  interface FichierFieldRefs {
    readonly id: FieldRef<"Fichier", 'Int'>
    readonly reservationId: FieldRef<"Fichier", 'Int'>
    readonly fileName: FieldRef<"Fichier", 'String'>
    readonly storedName: FieldRef<"Fichier", 'String'>
    readonly fileType: FieldRef<"Fichier", 'String'>
    readonly fileCategory: FieldRef<"Fichier", 'String'>
    readonly filePath: FieldRef<"Fichier", 'String'>
    readonly uploaded_at: FieldRef<"Fichier", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Fichier findUnique
   */
  export type FichierFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    /**
     * Filter, which Fichier to fetch.
     */
    where: FichierWhereUniqueInput
  }

  /**
   * Fichier findUniqueOrThrow
   */
  export type FichierFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    /**
     * Filter, which Fichier to fetch.
     */
    where: FichierWhereUniqueInput
  }

  /**
   * Fichier findFirst
   */
  export type FichierFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    /**
     * Filter, which Fichier to fetch.
     */
    where?: FichierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fichiers to fetch.
     */
    orderBy?: FichierOrderByWithRelationInput | FichierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fichiers.
     */
    cursor?: FichierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fichiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fichiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fichiers.
     */
    distinct?: FichierScalarFieldEnum | FichierScalarFieldEnum[]
  }

  /**
   * Fichier findFirstOrThrow
   */
  export type FichierFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    /**
     * Filter, which Fichier to fetch.
     */
    where?: FichierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fichiers to fetch.
     */
    orderBy?: FichierOrderByWithRelationInput | FichierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Fichiers.
     */
    cursor?: FichierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fichiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fichiers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Fichiers.
     */
    distinct?: FichierScalarFieldEnum | FichierScalarFieldEnum[]
  }

  /**
   * Fichier findMany
   */
  export type FichierFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    /**
     * Filter, which Fichiers to fetch.
     */
    where?: FichierWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Fichiers to fetch.
     */
    orderBy?: FichierOrderByWithRelationInput | FichierOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Fichiers.
     */
    cursor?: FichierWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Fichiers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Fichiers.
     */
    skip?: number
    distinct?: FichierScalarFieldEnum | FichierScalarFieldEnum[]
  }

  /**
   * Fichier create
   */
  export type FichierCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    /**
     * The data needed to create a Fichier.
     */
    data: XOR<FichierCreateInput, FichierUncheckedCreateInput>
  }

  /**
   * Fichier createMany
   */
  export type FichierCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Fichiers.
     */
    data: FichierCreateManyInput | FichierCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Fichier createManyAndReturn
   */
  export type FichierCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Fichiers.
     */
    data: FichierCreateManyInput | FichierCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Fichier update
   */
  export type FichierUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    /**
     * The data needed to update a Fichier.
     */
    data: XOR<FichierUpdateInput, FichierUncheckedUpdateInput>
    /**
     * Choose, which Fichier to update.
     */
    where: FichierWhereUniqueInput
  }

  /**
   * Fichier updateMany
   */
  export type FichierUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Fichiers.
     */
    data: XOR<FichierUpdateManyMutationInput, FichierUncheckedUpdateManyInput>
    /**
     * Filter which Fichiers to update
     */
    where?: FichierWhereInput
  }

  /**
   * Fichier upsert
   */
  export type FichierUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    /**
     * The filter to search for the Fichier to update in case it exists.
     */
    where: FichierWhereUniqueInput
    /**
     * In case the Fichier found by the `where` argument doesn't exist, create a new Fichier with this data.
     */
    create: XOR<FichierCreateInput, FichierUncheckedCreateInput>
    /**
     * In case the Fichier was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FichierUpdateInput, FichierUncheckedUpdateInput>
  }

  /**
   * Fichier delete
   */
  export type FichierDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    /**
     * Filter which Fichier to delete.
     */
    where: FichierWhereUniqueInput
  }

  /**
   * Fichier deleteMany
   */
  export type FichierDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Fichiers to delete
     */
    where?: FichierWhereInput
  }

  /**
   * Fichier.payment
   */
  export type Fichier$paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
  }

  /**
   * Fichier.expenses
   */
  export type Fichier$expensesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    cursor?: ExpenseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Fichier without action
   */
  export type FichierDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    id: number | null
    reservationId: number | null
    agentId: number | null
    amount: number | null
    fichierId: number | null
    programId: number | null
  }

  export type PaymentSumAggregateOutputType = {
    id: number | null
    reservationId: number | null
    agentId: number | null
    amount: number | null
    fichierId: number | null
    programId: number | null
  }

  export type PaymentMinAggregateOutputType = {
    id: number | null
    reservationId: number | null
    agentId: number | null
    amount: number | null
    paymentMethod: string | null
    paymentDate: Date | null
    fichierId: number | null
    programId: number | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: number | null
    reservationId: number | null
    agentId: number | null
    amount: number | null
    paymentMethod: string | null
    paymentDate: Date | null
    fichierId: number | null
    programId: number | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    reservationId: number
    agentId: number
    amount: number
    paymentMethod: number
    paymentDate: number
    fichierId: number
    programId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    id?: true
    reservationId?: true
    agentId?: true
    amount?: true
    fichierId?: true
    programId?: true
  }

  export type PaymentSumAggregateInputType = {
    id?: true
    reservationId?: true
    agentId?: true
    amount?: true
    fichierId?: true
    programId?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    reservationId?: true
    agentId?: true
    amount?: true
    paymentMethod?: true
    paymentDate?: true
    fichierId?: true
    programId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    reservationId?: true
    agentId?: true
    amount?: true
    paymentMethod?: true
    paymentDate?: true
    fichierId?: true
    programId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    reservationId?: true
    agentId?: true
    amount?: true
    paymentMethod?: true
    paymentDate?: true
    fichierId?: true
    programId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: number
    reservationId: number
    agentId: number | null
    amount: number
    paymentMethod: string
    paymentDate: Date
    fichierId: number | null
    programId: number | null
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservationId?: boolean
    agentId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    fichierId?: boolean
    programId?: boolean
    fichier?: boolean | Payment$fichierArgs<ExtArgs>
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    agent?: boolean | Payment$agentArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    reservationId?: boolean
    agentId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    fichierId?: boolean
    programId?: boolean
    fichier?: boolean | Payment$fichierArgs<ExtArgs>
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    agent?: boolean | Payment$agentArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    reservationId?: boolean
    agentId?: boolean
    amount?: boolean
    paymentMethod?: boolean
    paymentDate?: boolean
    fichierId?: boolean
    programId?: boolean
  }

  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fichier?: boolean | Payment$fichierArgs<ExtArgs>
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    agent?: boolean | Payment$agentArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    fichier?: boolean | Payment$fichierArgs<ExtArgs>
    reservation?: boolean | ReservationDefaultArgs<ExtArgs>
    agent?: boolean | Payment$agentArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      fichier: Prisma.$FichierPayload<ExtArgs> | null
      reservation: Prisma.$ReservationPayload<ExtArgs>
      agent: Prisma.$AgentPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      reservationId: number
      agentId: number | null
      amount: number
      paymentMethod: string
      paymentDate: Date
      fichierId: number | null
      programId: number | null
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    fichier<T extends Payment$fichierArgs<ExtArgs> = {}>(args?: Subset<T, Payment$fichierArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reservation<T extends ReservationDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ReservationDefaultArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    agent<T extends Payment$agentArgs<ExtArgs> = {}>(args?: Subset<T, Payment$agentArgs<ExtArgs>>): Prisma__AgentClient<$Result.GetResult<Prisma.$AgentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */ 
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'Int'>
    readonly reservationId: FieldRef<"Payment", 'Int'>
    readonly agentId: FieldRef<"Payment", 'Int'>
    readonly amount: FieldRef<"Payment", 'Float'>
    readonly paymentMethod: FieldRef<"Payment", 'String'>
    readonly paymentDate: FieldRef<"Payment", 'DateTime'>
    readonly fichierId: FieldRef<"Payment", 'Int'>
    readonly programId: FieldRef<"Payment", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
  }

  /**
   * Payment.fichier
   */
  export type Payment$fichierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    where?: FichierWhereInput
  }

  /**
   * Payment.agent
   */
  export type Payment$agentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Agent
     */
    select?: AgentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AgentInclude<ExtArgs> | null
    where?: AgentWhereInput
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Expense
   */

  export type AggregateExpense = {
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  export type ExpenseAvgAggregateOutputType = {
    id: number | null
    amount: number | null
    fichierId: number | null
    programId: number | null
    reservationId: number | null
  }

  export type ExpenseSumAggregateOutputType = {
    id: number | null
    amount: number | null
    fichierId: number | null
    programId: number | null
    reservationId: number | null
  }

  export type ExpenseMinAggregateOutputType = {
    id: number | null
    description: string | null
    amount: number | null
    date: Date | null
    type: string | null
    fichierId: number | null
    programId: number | null
    reservationId: number | null
  }

  export type ExpenseMaxAggregateOutputType = {
    id: number | null
    description: string | null
    amount: number | null
    date: Date | null
    type: string | null
    fichierId: number | null
    programId: number | null
    reservationId: number | null
  }

  export type ExpenseCountAggregateOutputType = {
    id: number
    description: number
    amount: number
    date: number
    type: number
    fichierId: number
    programId: number
    reservationId: number
    _all: number
  }


  export type ExpenseAvgAggregateInputType = {
    id?: true
    amount?: true
    fichierId?: true
    programId?: true
    reservationId?: true
  }

  export type ExpenseSumAggregateInputType = {
    id?: true
    amount?: true
    fichierId?: true
    programId?: true
    reservationId?: true
  }

  export type ExpenseMinAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    date?: true
    type?: true
    fichierId?: true
    programId?: true
    reservationId?: true
  }

  export type ExpenseMaxAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    date?: true
    type?: true
    fichierId?: true
    programId?: true
    reservationId?: true
  }

  export type ExpenseCountAggregateInputType = {
    id?: true
    description?: true
    amount?: true
    date?: true
    type?: true
    fichierId?: true
    programId?: true
    reservationId?: true
    _all?: true
  }

  export type ExpenseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expense to aggregate.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Expenses
    **/
    _count?: true | ExpenseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ExpenseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ExpenseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ExpenseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ExpenseMaxAggregateInputType
  }

  export type GetExpenseAggregateType<T extends ExpenseAggregateArgs> = {
        [P in keyof T & keyof AggregateExpense]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateExpense[P]>
      : GetScalarType<T[P], AggregateExpense[P]>
  }




  export type ExpenseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ExpenseWhereInput
    orderBy?: ExpenseOrderByWithAggregationInput | ExpenseOrderByWithAggregationInput[]
    by: ExpenseScalarFieldEnum[] | ExpenseScalarFieldEnum
    having?: ExpenseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ExpenseCountAggregateInputType | true
    _avg?: ExpenseAvgAggregateInputType
    _sum?: ExpenseSumAggregateInputType
    _min?: ExpenseMinAggregateInputType
    _max?: ExpenseMaxAggregateInputType
  }

  export type ExpenseGroupByOutputType = {
    id: number
    description: string
    amount: number
    date: Date
    type: string
    fichierId: number | null
    programId: number | null
    reservationId: number | null
    _count: ExpenseCountAggregateOutputType | null
    _avg: ExpenseAvgAggregateOutputType | null
    _sum: ExpenseSumAggregateOutputType | null
    _min: ExpenseMinAggregateOutputType | null
    _max: ExpenseMaxAggregateOutputType | null
  }

  type GetExpenseGroupByPayload<T extends ExpenseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ExpenseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ExpenseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
            : GetScalarType<T[P], ExpenseGroupByOutputType[P]>
        }
      >
    >


  export type ExpenseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    date?: boolean
    type?: boolean
    fichierId?: boolean
    programId?: boolean
    reservationId?: boolean
    program?: boolean | Expense$programArgs<ExtArgs>
    reservation?: boolean | Expense$reservationArgs<ExtArgs>
    fichier?: boolean | Expense$fichierArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    description?: boolean
    amount?: boolean
    date?: boolean
    type?: boolean
    fichierId?: boolean
    programId?: boolean
    reservationId?: boolean
    program?: boolean | Expense$programArgs<ExtArgs>
    reservation?: boolean | Expense$reservationArgs<ExtArgs>
    fichier?: boolean | Expense$fichierArgs<ExtArgs>
  }, ExtArgs["result"]["expense"]>

  export type ExpenseSelectScalar = {
    id?: boolean
    description?: boolean
    amount?: boolean
    date?: boolean
    type?: boolean
    fichierId?: boolean
    programId?: boolean
    reservationId?: boolean
  }

  export type ExpenseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Expense$programArgs<ExtArgs>
    reservation?: boolean | Expense$reservationArgs<ExtArgs>
    fichier?: boolean | Expense$fichierArgs<ExtArgs>
  }
  export type ExpenseIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    program?: boolean | Expense$programArgs<ExtArgs>
    reservation?: boolean | Expense$reservationArgs<ExtArgs>
    fichier?: boolean | Expense$fichierArgs<ExtArgs>
  }

  export type $ExpensePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Expense"
    objects: {
      program: Prisma.$ProgramPayload<ExtArgs> | null
      reservation: Prisma.$ReservationPayload<ExtArgs> | null
      fichier: Prisma.$FichierPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: number
      description: string
      amount: number
      date: Date
      type: string
      fichierId: number | null
      programId: number | null
      reservationId: number | null
    }, ExtArgs["result"]["expense"]>
    composites: {}
  }

  type ExpenseGetPayload<S extends boolean | null | undefined | ExpenseDefaultArgs> = $Result.GetResult<Prisma.$ExpensePayload, S>

  type ExpenseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ExpenseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ExpenseCountAggregateInputType | true
    }

  export interface ExpenseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Expense'], meta: { name: 'Expense' } }
    /**
     * Find zero or one Expense that matches the filter.
     * @param {ExpenseFindUniqueArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ExpenseFindUniqueArgs>(args: SelectSubset<T, ExpenseFindUniqueArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Expense that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ExpenseFindUniqueOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ExpenseFindUniqueOrThrowArgs>(args: SelectSubset<T, ExpenseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Expense that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ExpenseFindFirstArgs>(args?: SelectSubset<T, ExpenseFindFirstArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Expense that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindFirstOrThrowArgs} args - Arguments to find a Expense
     * @example
     * // Get one Expense
     * const expense = await prisma.expense.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ExpenseFindFirstOrThrowArgs>(args?: SelectSubset<T, ExpenseFindFirstOrThrowArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Expenses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Expenses
     * const expenses = await prisma.expense.findMany()
     * 
     * // Get first 10 Expenses
     * const expenses = await prisma.expense.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const expenseWithIdOnly = await prisma.expense.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ExpenseFindManyArgs>(args?: SelectSubset<T, ExpenseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Expense.
     * @param {ExpenseCreateArgs} args - Arguments to create a Expense.
     * @example
     * // Create one Expense
     * const Expense = await prisma.expense.create({
     *   data: {
     *     // ... data to create a Expense
     *   }
     * })
     * 
     */
    create<T extends ExpenseCreateArgs>(args: SelectSubset<T, ExpenseCreateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Expenses.
     * @param {ExpenseCreateManyArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ExpenseCreateManyArgs>(args?: SelectSubset<T, ExpenseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Expenses and returns the data saved in the database.
     * @param {ExpenseCreateManyAndReturnArgs} args - Arguments to create many Expenses.
     * @example
     * // Create many Expenses
     * const expense = await prisma.expense.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Expenses and only return the `id`
     * const expenseWithIdOnly = await prisma.expense.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ExpenseCreateManyAndReturnArgs>(args?: SelectSubset<T, ExpenseCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Expense.
     * @param {ExpenseDeleteArgs} args - Arguments to delete one Expense.
     * @example
     * // Delete one Expense
     * const Expense = await prisma.expense.delete({
     *   where: {
     *     // ... filter to delete one Expense
     *   }
     * })
     * 
     */
    delete<T extends ExpenseDeleteArgs>(args: SelectSubset<T, ExpenseDeleteArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Expense.
     * @param {ExpenseUpdateArgs} args - Arguments to update one Expense.
     * @example
     * // Update one Expense
     * const expense = await prisma.expense.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ExpenseUpdateArgs>(args: SelectSubset<T, ExpenseUpdateArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Expenses.
     * @param {ExpenseDeleteManyArgs} args - Arguments to filter Expenses to delete.
     * @example
     * // Delete a few Expenses
     * const { count } = await prisma.expense.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ExpenseDeleteManyArgs>(args?: SelectSubset<T, ExpenseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Expenses
     * const expense = await prisma.expense.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ExpenseUpdateManyArgs>(args: SelectSubset<T, ExpenseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Expense.
     * @param {ExpenseUpsertArgs} args - Arguments to update or create a Expense.
     * @example
     * // Update or create a Expense
     * const expense = await prisma.expense.upsert({
     *   create: {
     *     // ... data to create a Expense
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Expense we want to update
     *   }
     * })
     */
    upsert<T extends ExpenseUpsertArgs>(args: SelectSubset<T, ExpenseUpsertArgs<ExtArgs>>): Prisma__ExpenseClient<$Result.GetResult<Prisma.$ExpensePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Expenses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseCountArgs} args - Arguments to filter Expenses to count.
     * @example
     * // Count the number of Expenses
     * const count = await prisma.expense.count({
     *   where: {
     *     // ... the filter for the Expenses we want to count
     *   }
     * })
    **/
    count<T extends ExpenseCountArgs>(
      args?: Subset<T, ExpenseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ExpenseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ExpenseAggregateArgs>(args: Subset<T, ExpenseAggregateArgs>): Prisma.PrismaPromise<GetExpenseAggregateType<T>>

    /**
     * Group by Expense.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ExpenseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ExpenseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ExpenseGroupByArgs['orderBy'] }
        : { orderBy?: ExpenseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ExpenseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetExpenseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Expense model
   */
  readonly fields: ExpenseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Expense.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ExpenseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    program<T extends Expense$programArgs<ExtArgs> = {}>(args?: Subset<T, Expense$programArgs<ExtArgs>>): Prisma__ProgramClient<$Result.GetResult<Prisma.$ProgramPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    reservation<T extends Expense$reservationArgs<ExtArgs> = {}>(args?: Subset<T, Expense$reservationArgs<ExtArgs>>): Prisma__ReservationClient<$Result.GetResult<Prisma.$ReservationPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    fichier<T extends Expense$fichierArgs<ExtArgs> = {}>(args?: Subset<T, Expense$fichierArgs<ExtArgs>>): Prisma__FichierClient<$Result.GetResult<Prisma.$FichierPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Expense model
   */ 
  interface ExpenseFieldRefs {
    readonly id: FieldRef<"Expense", 'Int'>
    readonly description: FieldRef<"Expense", 'String'>
    readonly amount: FieldRef<"Expense", 'Float'>
    readonly date: FieldRef<"Expense", 'DateTime'>
    readonly type: FieldRef<"Expense", 'String'>
    readonly fichierId: FieldRef<"Expense", 'Int'>
    readonly programId: FieldRef<"Expense", 'Int'>
    readonly reservationId: FieldRef<"Expense", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * Expense findUnique
   */
  export type ExpenseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findUniqueOrThrow
   */
  export type ExpenseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense findFirst
   */
  export type ExpenseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findFirstOrThrow
   */
  export type ExpenseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expense to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Expenses.
     */
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense findMany
   */
  export type ExpenseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter, which Expenses to fetch.
     */
    where?: ExpenseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Expenses to fetch.
     */
    orderBy?: ExpenseOrderByWithRelationInput | ExpenseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Expenses.
     */
    cursor?: ExpenseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Expenses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Expenses.
     */
    skip?: number
    distinct?: ExpenseScalarFieldEnum | ExpenseScalarFieldEnum[]
  }

  /**
   * Expense create
   */
  export type ExpenseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to create a Expense.
     */
    data: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
  }

  /**
   * Expense createMany
   */
  export type ExpenseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Expense createManyAndReturn
   */
  export type ExpenseCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Expenses.
     */
    data: ExpenseCreateManyInput | ExpenseCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Expense update
   */
  export type ExpenseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The data needed to update a Expense.
     */
    data: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
    /**
     * Choose, which Expense to update.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense updateMany
   */
  export type ExpenseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Expenses.
     */
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyInput>
    /**
     * Filter which Expenses to update
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense upsert
   */
  export type ExpenseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * The filter to search for the Expense to update in case it exists.
     */
    where: ExpenseWhereUniqueInput
    /**
     * In case the Expense found by the `where` argument doesn't exist, create a new Expense with this data.
     */
    create: XOR<ExpenseCreateInput, ExpenseUncheckedCreateInput>
    /**
     * In case the Expense was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ExpenseUpdateInput, ExpenseUncheckedUpdateInput>
  }

  /**
   * Expense delete
   */
  export type ExpenseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
    /**
     * Filter which Expense to delete.
     */
    where: ExpenseWhereUniqueInput
  }

  /**
   * Expense deleteMany
   */
  export type ExpenseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Expenses to delete
     */
    where?: ExpenseWhereInput
  }

  /**
   * Expense.program
   */
  export type Expense$programArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Program
     */
    select?: ProgramSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProgramInclude<ExtArgs> | null
    where?: ProgramWhereInput
  }

  /**
   * Expense.reservation
   */
  export type Expense$reservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Reservation
     */
    select?: ReservationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ReservationInclude<ExtArgs> | null
    where?: ReservationWhereInput
  }

  /**
   * Expense.fichier
   */
  export type Expense$fichierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Fichier
     */
    select?: FichierSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FichierInclude<ExtArgs> | null
    where?: FichierWhereInput
  }

  /**
   * Expense without action
   */
  export type ExpenseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Expense
     */
    select?: ExpenseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ExpenseInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    name: 'name',
    role: 'role',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const AgentScalarFieldEnum: {
    id: 'id',
    nom: 'nom',
    email: 'email',
    motDePasse: 'motDePasse',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type AgentScalarFieldEnum = (typeof AgentScalarFieldEnum)[keyof typeof AgentScalarFieldEnum]


  export const ProgramScalarFieldEnum: {
    id: 'id',
    name: 'name',
    created_at: 'created_at',
    visaDeadline: 'visaDeadline',
    hotelDeadline: 'hotelDeadline',
    flightDeadline: 'flightDeadline',
    passportDeadline: 'passportDeadline',
    nbJoursMadina: 'nbJoursMadina',
    nbJoursMakkah: 'nbJoursMakkah',
    exchange: 'exchange',
    prixAvionDH: 'prixAvionDH',
    prixVisaRiyal: 'prixVisaRiyal',
    profit: 'profit'
  };

  export type ProgramScalarFieldEnum = (typeof ProgramScalarFieldEnum)[keyof typeof ProgramScalarFieldEnum]


  export const HotelScalarFieldEnum: {
    id: 'id',
    name: 'name',
    city: 'city'
  };

  export type HotelScalarFieldEnum = (typeof HotelScalarFieldEnum)[keyof typeof HotelScalarFieldEnum]


  export const ProgramHotelMadinaScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    hotelId: 'hotelId'
  };

  export type ProgramHotelMadinaScalarFieldEnum = (typeof ProgramHotelMadinaScalarFieldEnum)[keyof typeof ProgramHotelMadinaScalarFieldEnum]


  export const ProgramHotelMakkahScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    hotelId: 'hotelId'
  };

  export type ProgramHotelMakkahScalarFieldEnum = (typeof ProgramHotelMakkahScalarFieldEnum)[keyof typeof ProgramHotelMakkahScalarFieldEnum]


  export const RoomScalarFieldEnum: {
    id: 'id',
    programId: 'programId',
    hotelId: 'hotelId',
    roomType: 'roomType',
    gender: 'gender',
    nbrPlaceTotal: 'nbrPlaceTotal',
    nbrPlaceRestantes: 'nbrPlaceRestantes',
    prixRoom: 'prixRoom',
    listeIdsReservation: 'listeIdsReservation',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type RoomScalarFieldEnum = (typeof RoomScalarFieldEnum)[keyof typeof RoomScalarFieldEnum]


  export const ReservationScalarFieldEnum: {
    id: 'id',
    firstName: 'firstName',
    lastName: 'lastName',
    phone: 'phone',
    programId: 'programId',
    roomType: 'roomType',
    gender: 'gender',
    hotelMadina: 'hotelMadina',
    hotelMakkah: 'hotelMakkah',
    price: 'price',
    reduction: 'reduction',
    paidAmount: 'paidAmount',
    status: 'status',
    statutPasseport: 'statutPasseport',
    statutVisa: 'statutVisa',
    statutHotel: 'statutHotel',
    statutVol: 'statutVol',
    reservationDate: 'reservationDate',
    created_at: 'created_at',
    updated_at: 'updated_at',
    agentId: 'agentId'
  };

  export type ReservationScalarFieldEnum = (typeof ReservationScalarFieldEnum)[keyof typeof ReservationScalarFieldEnum]


  export const FichierScalarFieldEnum: {
    id: 'id',
    reservationId: 'reservationId',
    fileName: 'fileName',
    storedName: 'storedName',
    fileType: 'fileType',
    fileCategory: 'fileCategory',
    filePath: 'filePath',
    uploaded_at: 'uploaded_at'
  };

  export type FichierScalarFieldEnum = (typeof FichierScalarFieldEnum)[keyof typeof FichierScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    reservationId: 'reservationId',
    agentId: 'agentId',
    amount: 'amount',
    paymentMethod: 'paymentMethod',
    paymentDate: 'paymentDate',
    fichierId: 'fichierId',
    programId: 'programId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const ExpenseScalarFieldEnum: {
    id: 'id',
    description: 'description',
    amount: 'amount',
    date: 'date',
    type: 'type',
    fichierId: 'fichierId',
    programId: 'programId',
    reservationId: 'reservationId'
  };

  export type ExpenseScalarFieldEnum = (typeof ExpenseScalarFieldEnum)[keyof typeof ExpenseScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'City'
   */
  export type EnumCityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'City'>
    


  /**
   * Reference to a field of type 'City[]'
   */
  export type ListEnumCityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'City[]'>
    


  /**
   * Reference to a field of type 'RoomType'
   */
  export type EnumRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomType'>
    


  /**
   * Reference to a field of type 'RoomType[]'
   */
  export type ListEnumRoomTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RoomType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: IntFilter<"User"> | number
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    name?: StringFilter<"User"> | string
    role?: EnumRoleFilter<"User"> | $Enums.Role
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"User"> | number
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumRoleWithAggregatesFilter<"User"> | $Enums.Role
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type AgentWhereInput = {
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    id?: IntFilter<"Agent"> | number
    nom?: StringFilter<"Agent"> | string
    email?: StringNullableFilter<"Agent"> | string | null
    motDePasse?: StringFilter<"Agent"> | string
    isActive?: BoolFilter<"Agent"> | boolean
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    reservations?: ReservationListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type AgentOrderByWithRelationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrderInput | SortOrder
    motDePasse?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    reservations?: ReservationOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type AgentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    email?: string
    AND?: AgentWhereInput | AgentWhereInput[]
    OR?: AgentWhereInput[]
    NOT?: AgentWhereInput | AgentWhereInput[]
    nom?: StringFilter<"Agent"> | string
    motDePasse?: StringFilter<"Agent"> | string
    isActive?: BoolFilter<"Agent"> | boolean
    createdAt?: DateTimeFilter<"Agent"> | Date | string
    updatedAt?: DateTimeFilter<"Agent"> | Date | string
    reservations?: ReservationListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id" | "email">

  export type AgentOrderByWithAggregationInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrderInput | SortOrder
    motDePasse?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: AgentCountOrderByAggregateInput
    _avg?: AgentAvgOrderByAggregateInput
    _max?: AgentMaxOrderByAggregateInput
    _min?: AgentMinOrderByAggregateInput
    _sum?: AgentSumOrderByAggregateInput
  }

  export type AgentScalarWhereWithAggregatesInput = {
    AND?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    OR?: AgentScalarWhereWithAggregatesInput[]
    NOT?: AgentScalarWhereWithAggregatesInput | AgentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Agent"> | number
    nom?: StringWithAggregatesFilter<"Agent"> | string
    email?: StringNullableWithAggregatesFilter<"Agent"> | string | null
    motDePasse?: StringWithAggregatesFilter<"Agent"> | string
    isActive?: BoolWithAggregatesFilter<"Agent"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Agent"> | Date | string
  }

  export type ProgramWhereInput = {
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    id?: IntFilter<"Program"> | number
    name?: StringFilter<"Program"> | string
    created_at?: DateTimeFilter<"Program"> | Date | string
    visaDeadline?: DateTimeNullableFilter<"Program"> | Date | string | null
    hotelDeadline?: DateTimeNullableFilter<"Program"> | Date | string | null
    flightDeadline?: DateTimeNullableFilter<"Program"> | Date | string | null
    passportDeadline?: DateTimeNullableFilter<"Program"> | Date | string | null
    nbJoursMadina?: IntFilter<"Program"> | number
    nbJoursMakkah?: IntFilter<"Program"> | number
    exchange?: FloatFilter<"Program"> | number
    prixAvionDH?: FloatFilter<"Program"> | number
    prixVisaRiyal?: FloatFilter<"Program"> | number
    profit?: FloatFilter<"Program"> | number
    expenses?: ExpenseListRelationFilter
    hotelsMadina?: ProgramHotelMadinaListRelationFilter
    hotelsMakkah?: ProgramHotelMakkahListRelationFilter
    rooms?: RoomListRelationFilter
    reservations?: ReservationListRelationFilter
  }

  export type ProgramOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    visaDeadline?: SortOrderInput | SortOrder
    hotelDeadline?: SortOrderInput | SortOrder
    flightDeadline?: SortOrderInput | SortOrder
    passportDeadline?: SortOrderInput | SortOrder
    nbJoursMadina?: SortOrder
    nbJoursMakkah?: SortOrder
    exchange?: SortOrder
    prixAvionDH?: SortOrder
    prixVisaRiyal?: SortOrder
    profit?: SortOrder
    expenses?: ExpenseOrderByRelationAggregateInput
    hotelsMadina?: ProgramHotelMadinaOrderByRelationAggregateInput
    hotelsMakkah?: ProgramHotelMakkahOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
    reservations?: ReservationOrderByRelationAggregateInput
  }

  export type ProgramWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ProgramWhereInput | ProgramWhereInput[]
    OR?: ProgramWhereInput[]
    NOT?: ProgramWhereInput | ProgramWhereInput[]
    name?: StringFilter<"Program"> | string
    created_at?: DateTimeFilter<"Program"> | Date | string
    visaDeadline?: DateTimeNullableFilter<"Program"> | Date | string | null
    hotelDeadline?: DateTimeNullableFilter<"Program"> | Date | string | null
    flightDeadline?: DateTimeNullableFilter<"Program"> | Date | string | null
    passportDeadline?: DateTimeNullableFilter<"Program"> | Date | string | null
    nbJoursMadina?: IntFilter<"Program"> | number
    nbJoursMakkah?: IntFilter<"Program"> | number
    exchange?: FloatFilter<"Program"> | number
    prixAvionDH?: FloatFilter<"Program"> | number
    prixVisaRiyal?: FloatFilter<"Program"> | number
    profit?: FloatFilter<"Program"> | number
    expenses?: ExpenseListRelationFilter
    hotelsMadina?: ProgramHotelMadinaListRelationFilter
    hotelsMakkah?: ProgramHotelMakkahListRelationFilter
    rooms?: RoomListRelationFilter
    reservations?: ReservationListRelationFilter
  }, "id">

  export type ProgramOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    visaDeadline?: SortOrderInput | SortOrder
    hotelDeadline?: SortOrderInput | SortOrder
    flightDeadline?: SortOrderInput | SortOrder
    passportDeadline?: SortOrderInput | SortOrder
    nbJoursMadina?: SortOrder
    nbJoursMakkah?: SortOrder
    exchange?: SortOrder
    prixAvionDH?: SortOrder
    prixVisaRiyal?: SortOrder
    profit?: SortOrder
    _count?: ProgramCountOrderByAggregateInput
    _avg?: ProgramAvgOrderByAggregateInput
    _max?: ProgramMaxOrderByAggregateInput
    _min?: ProgramMinOrderByAggregateInput
    _sum?: ProgramSumOrderByAggregateInput
  }

  export type ProgramScalarWhereWithAggregatesInput = {
    AND?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    OR?: ProgramScalarWhereWithAggregatesInput[]
    NOT?: ProgramScalarWhereWithAggregatesInput | ProgramScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Program"> | number
    name?: StringWithAggregatesFilter<"Program"> | string
    created_at?: DateTimeWithAggregatesFilter<"Program"> | Date | string
    visaDeadline?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    hotelDeadline?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    flightDeadline?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    passportDeadline?: DateTimeNullableWithAggregatesFilter<"Program"> | Date | string | null
    nbJoursMadina?: IntWithAggregatesFilter<"Program"> | number
    nbJoursMakkah?: IntWithAggregatesFilter<"Program"> | number
    exchange?: FloatWithAggregatesFilter<"Program"> | number
    prixAvionDH?: FloatWithAggregatesFilter<"Program"> | number
    prixVisaRiyal?: FloatWithAggregatesFilter<"Program"> | number
    profit?: FloatWithAggregatesFilter<"Program"> | number
  }

  export type HotelWhereInput = {
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    id?: IntFilter<"Hotel"> | number
    name?: StringFilter<"Hotel"> | string
    city?: EnumCityFilter<"Hotel"> | $Enums.City
    programsMadina?: ProgramHotelMadinaListRelationFilter
    programsMakkah?: ProgramHotelMakkahListRelationFilter
    rooms?: RoomListRelationFilter
  }

  export type HotelOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    programsMadina?: ProgramHotelMadinaOrderByRelationAggregateInput
    programsMakkah?: ProgramHotelMakkahOrderByRelationAggregateInput
    rooms?: RoomOrderByRelationAggregateInput
  }

  export type HotelWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    name_city?: HotelNameCityCompoundUniqueInput
    AND?: HotelWhereInput | HotelWhereInput[]
    OR?: HotelWhereInput[]
    NOT?: HotelWhereInput | HotelWhereInput[]
    name?: StringFilter<"Hotel"> | string
    city?: EnumCityFilter<"Hotel"> | $Enums.City
    programsMadina?: ProgramHotelMadinaListRelationFilter
    programsMakkah?: ProgramHotelMakkahListRelationFilter
    rooms?: RoomListRelationFilter
  }, "id" | "name_city">

  export type HotelOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
    _count?: HotelCountOrderByAggregateInput
    _avg?: HotelAvgOrderByAggregateInput
    _max?: HotelMaxOrderByAggregateInput
    _min?: HotelMinOrderByAggregateInput
    _sum?: HotelSumOrderByAggregateInput
  }

  export type HotelScalarWhereWithAggregatesInput = {
    AND?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    OR?: HotelScalarWhereWithAggregatesInput[]
    NOT?: HotelScalarWhereWithAggregatesInput | HotelScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Hotel"> | number
    name?: StringWithAggregatesFilter<"Hotel"> | string
    city?: EnumCityWithAggregatesFilter<"Hotel"> | $Enums.City
  }

  export type ProgramHotelMadinaWhereInput = {
    AND?: ProgramHotelMadinaWhereInput | ProgramHotelMadinaWhereInput[]
    OR?: ProgramHotelMadinaWhereInput[]
    NOT?: ProgramHotelMadinaWhereInput | ProgramHotelMadinaWhereInput[]
    id?: IntFilter<"ProgramHotelMadina"> | number
    programId?: IntFilter<"ProgramHotelMadina"> | number
    hotelId?: IntFilter<"ProgramHotelMadina"> | number
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }

  export type ProgramHotelMadinaOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    program?: ProgramOrderByWithRelationInput
    hotel?: HotelOrderByWithRelationInput
  }

  export type ProgramHotelMadinaWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    programId_hotelId?: ProgramHotelMadinaProgramIdHotelIdCompoundUniqueInput
    AND?: ProgramHotelMadinaWhereInput | ProgramHotelMadinaWhereInput[]
    OR?: ProgramHotelMadinaWhereInput[]
    NOT?: ProgramHotelMadinaWhereInput | ProgramHotelMadinaWhereInput[]
    programId?: IntFilter<"ProgramHotelMadina"> | number
    hotelId?: IntFilter<"ProgramHotelMadina"> | number
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }, "id" | "programId_hotelId">

  export type ProgramHotelMadinaOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    _count?: ProgramHotelMadinaCountOrderByAggregateInput
    _avg?: ProgramHotelMadinaAvgOrderByAggregateInput
    _max?: ProgramHotelMadinaMaxOrderByAggregateInput
    _min?: ProgramHotelMadinaMinOrderByAggregateInput
    _sum?: ProgramHotelMadinaSumOrderByAggregateInput
  }

  export type ProgramHotelMadinaScalarWhereWithAggregatesInput = {
    AND?: ProgramHotelMadinaScalarWhereWithAggregatesInput | ProgramHotelMadinaScalarWhereWithAggregatesInput[]
    OR?: ProgramHotelMadinaScalarWhereWithAggregatesInput[]
    NOT?: ProgramHotelMadinaScalarWhereWithAggregatesInput | ProgramHotelMadinaScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProgramHotelMadina"> | number
    programId?: IntWithAggregatesFilter<"ProgramHotelMadina"> | number
    hotelId?: IntWithAggregatesFilter<"ProgramHotelMadina"> | number
  }

  export type ProgramHotelMakkahWhereInput = {
    AND?: ProgramHotelMakkahWhereInput | ProgramHotelMakkahWhereInput[]
    OR?: ProgramHotelMakkahWhereInput[]
    NOT?: ProgramHotelMakkahWhereInput | ProgramHotelMakkahWhereInput[]
    id?: IntFilter<"ProgramHotelMakkah"> | number
    programId?: IntFilter<"ProgramHotelMakkah"> | number
    hotelId?: IntFilter<"ProgramHotelMakkah"> | number
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }

  export type ProgramHotelMakkahOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    program?: ProgramOrderByWithRelationInput
    hotel?: HotelOrderByWithRelationInput
  }

  export type ProgramHotelMakkahWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    programId_hotelId?: ProgramHotelMakkahProgramIdHotelIdCompoundUniqueInput
    AND?: ProgramHotelMakkahWhereInput | ProgramHotelMakkahWhereInput[]
    OR?: ProgramHotelMakkahWhereInput[]
    NOT?: ProgramHotelMakkahWhereInput | ProgramHotelMakkahWhereInput[]
    programId?: IntFilter<"ProgramHotelMakkah"> | number
    hotelId?: IntFilter<"ProgramHotelMakkah"> | number
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }, "id" | "programId_hotelId">

  export type ProgramHotelMakkahOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    _count?: ProgramHotelMakkahCountOrderByAggregateInput
    _avg?: ProgramHotelMakkahAvgOrderByAggregateInput
    _max?: ProgramHotelMakkahMaxOrderByAggregateInput
    _min?: ProgramHotelMakkahMinOrderByAggregateInput
    _sum?: ProgramHotelMakkahSumOrderByAggregateInput
  }

  export type ProgramHotelMakkahScalarWhereWithAggregatesInput = {
    AND?: ProgramHotelMakkahScalarWhereWithAggregatesInput | ProgramHotelMakkahScalarWhereWithAggregatesInput[]
    OR?: ProgramHotelMakkahScalarWhereWithAggregatesInput[]
    NOT?: ProgramHotelMakkahScalarWhereWithAggregatesInput | ProgramHotelMakkahScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"ProgramHotelMakkah"> | number
    programId?: IntWithAggregatesFilter<"ProgramHotelMakkah"> | number
    hotelId?: IntWithAggregatesFilter<"ProgramHotelMakkah"> | number
  }

  export type RoomWhereInput = {
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    id?: IntFilter<"Room"> | number
    programId?: IntFilter<"Room"> | number
    hotelId?: IntFilter<"Room"> | number
    roomType?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    gender?: StringFilter<"Room"> | string
    nbrPlaceTotal?: IntFilter<"Room"> | number
    nbrPlaceRestantes?: IntFilter<"Room"> | number
    prixRoom?: FloatFilter<"Room"> | number
    listeIdsReservation?: IntNullableListFilter<"Room">
    created_at?: DateTimeFilter<"Room"> | Date | string
    updated_at?: DateTimeFilter<"Room"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }

  export type RoomOrderByWithRelationInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    nbrPlaceTotal?: SortOrder
    nbrPlaceRestantes?: SortOrder
    prixRoom?: SortOrder
    listeIdsReservation?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    program?: ProgramOrderByWithRelationInput
    hotel?: HotelOrderByWithRelationInput
  }

  export type RoomWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: RoomWhereInput | RoomWhereInput[]
    OR?: RoomWhereInput[]
    NOT?: RoomWhereInput | RoomWhereInput[]
    programId?: IntFilter<"Room"> | number
    hotelId?: IntFilter<"Room"> | number
    roomType?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    gender?: StringFilter<"Room"> | string
    nbrPlaceTotal?: IntFilter<"Room"> | number
    nbrPlaceRestantes?: IntFilter<"Room"> | number
    prixRoom?: FloatFilter<"Room"> | number
    listeIdsReservation?: IntNullableListFilter<"Room">
    created_at?: DateTimeFilter<"Room"> | Date | string
    updated_at?: DateTimeFilter<"Room"> | Date | string
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    hotel?: XOR<HotelRelationFilter, HotelWhereInput>
  }, "id">

  export type RoomOrderByWithAggregationInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    nbrPlaceTotal?: SortOrder
    nbrPlaceRestantes?: SortOrder
    prixRoom?: SortOrder
    listeIdsReservation?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: RoomCountOrderByAggregateInput
    _avg?: RoomAvgOrderByAggregateInput
    _max?: RoomMaxOrderByAggregateInput
    _min?: RoomMinOrderByAggregateInput
    _sum?: RoomSumOrderByAggregateInput
  }

  export type RoomScalarWhereWithAggregatesInput = {
    AND?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    OR?: RoomScalarWhereWithAggregatesInput[]
    NOT?: RoomScalarWhereWithAggregatesInput | RoomScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Room"> | number
    programId?: IntWithAggregatesFilter<"Room"> | number
    hotelId?: IntWithAggregatesFilter<"Room"> | number
    roomType?: EnumRoomTypeWithAggregatesFilter<"Room"> | $Enums.RoomType
    gender?: StringWithAggregatesFilter<"Room"> | string
    nbrPlaceTotal?: IntWithAggregatesFilter<"Room"> | number
    nbrPlaceRestantes?: IntWithAggregatesFilter<"Room"> | number
    prixRoom?: FloatWithAggregatesFilter<"Room"> | number
    listeIdsReservation?: IntNullableListFilter<"Room">
    created_at?: DateTimeWithAggregatesFilter<"Room"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Room"> | Date | string
  }

  export type ReservationWhereInput = {
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    id?: IntFilter<"Reservation"> | number
    firstName?: StringFilter<"Reservation"> | string
    lastName?: StringFilter<"Reservation"> | string
    phone?: StringFilter<"Reservation"> | string
    programId?: IntFilter<"Reservation"> | number
    roomType?: EnumRoomTypeFilter<"Reservation"> | $Enums.RoomType
    gender?: StringFilter<"Reservation"> | string
    hotelMadina?: StringNullableFilter<"Reservation"> | string | null
    hotelMakkah?: StringNullableFilter<"Reservation"> | string | null
    price?: FloatFilter<"Reservation"> | number
    reduction?: FloatFilter<"Reservation"> | number
    paidAmount?: FloatFilter<"Reservation"> | number
    status?: StringFilter<"Reservation"> | string
    statutPasseport?: BoolFilter<"Reservation"> | boolean
    statutVisa?: BoolFilter<"Reservation"> | boolean
    statutHotel?: BoolFilter<"Reservation"> | boolean
    statutVol?: BoolFilter<"Reservation"> | boolean
    reservationDate?: DateTimeFilter<"Reservation"> | Date | string
    created_at?: DateTimeFilter<"Reservation"> | Date | string
    updated_at?: DateTimeFilter<"Reservation"> | Date | string
    agentId?: IntNullableFilter<"Reservation"> | number | null
    documents?: FichierListRelationFilter
    payments?: PaymentListRelationFilter
    expenses?: ExpenseListRelationFilter
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    agent?: XOR<AgentNullableRelationFilter, AgentWhereInput> | null
  }

  export type ReservationOrderByWithRelationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    programId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    hotelMadina?: SortOrderInput | SortOrder
    hotelMakkah?: SortOrderInput | SortOrder
    price?: SortOrder
    reduction?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    statutPasseport?: SortOrder
    statutVisa?: SortOrder
    statutHotel?: SortOrder
    statutVol?: SortOrder
    reservationDate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agentId?: SortOrderInput | SortOrder
    documents?: FichierOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    expenses?: ExpenseOrderByRelationAggregateInput
    program?: ProgramOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type ReservationWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ReservationWhereInput | ReservationWhereInput[]
    OR?: ReservationWhereInput[]
    NOT?: ReservationWhereInput | ReservationWhereInput[]
    firstName?: StringFilter<"Reservation"> | string
    lastName?: StringFilter<"Reservation"> | string
    phone?: StringFilter<"Reservation"> | string
    programId?: IntFilter<"Reservation"> | number
    roomType?: EnumRoomTypeFilter<"Reservation"> | $Enums.RoomType
    gender?: StringFilter<"Reservation"> | string
    hotelMadina?: StringNullableFilter<"Reservation"> | string | null
    hotelMakkah?: StringNullableFilter<"Reservation"> | string | null
    price?: FloatFilter<"Reservation"> | number
    reduction?: FloatFilter<"Reservation"> | number
    paidAmount?: FloatFilter<"Reservation"> | number
    status?: StringFilter<"Reservation"> | string
    statutPasseport?: BoolFilter<"Reservation"> | boolean
    statutVisa?: BoolFilter<"Reservation"> | boolean
    statutHotel?: BoolFilter<"Reservation"> | boolean
    statutVol?: BoolFilter<"Reservation"> | boolean
    reservationDate?: DateTimeFilter<"Reservation"> | Date | string
    created_at?: DateTimeFilter<"Reservation"> | Date | string
    updated_at?: DateTimeFilter<"Reservation"> | Date | string
    agentId?: IntNullableFilter<"Reservation"> | number | null
    documents?: FichierListRelationFilter
    payments?: PaymentListRelationFilter
    expenses?: ExpenseListRelationFilter
    program?: XOR<ProgramRelationFilter, ProgramWhereInput>
    agent?: XOR<AgentNullableRelationFilter, AgentWhereInput> | null
  }, "id">

  export type ReservationOrderByWithAggregationInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    programId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    hotelMadina?: SortOrderInput | SortOrder
    hotelMakkah?: SortOrderInput | SortOrder
    price?: SortOrder
    reduction?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    statutPasseport?: SortOrder
    statutVisa?: SortOrder
    statutHotel?: SortOrder
    statutVol?: SortOrder
    reservationDate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agentId?: SortOrderInput | SortOrder
    _count?: ReservationCountOrderByAggregateInput
    _avg?: ReservationAvgOrderByAggregateInput
    _max?: ReservationMaxOrderByAggregateInput
    _min?: ReservationMinOrderByAggregateInput
    _sum?: ReservationSumOrderByAggregateInput
  }

  export type ReservationScalarWhereWithAggregatesInput = {
    AND?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    OR?: ReservationScalarWhereWithAggregatesInput[]
    NOT?: ReservationScalarWhereWithAggregatesInput | ReservationScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Reservation"> | number
    firstName?: StringWithAggregatesFilter<"Reservation"> | string
    lastName?: StringWithAggregatesFilter<"Reservation"> | string
    phone?: StringWithAggregatesFilter<"Reservation"> | string
    programId?: IntWithAggregatesFilter<"Reservation"> | number
    roomType?: EnumRoomTypeWithAggregatesFilter<"Reservation"> | $Enums.RoomType
    gender?: StringWithAggregatesFilter<"Reservation"> | string
    hotelMadina?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    hotelMakkah?: StringNullableWithAggregatesFilter<"Reservation"> | string | null
    price?: FloatWithAggregatesFilter<"Reservation"> | number
    reduction?: FloatWithAggregatesFilter<"Reservation"> | number
    paidAmount?: FloatWithAggregatesFilter<"Reservation"> | number
    status?: StringWithAggregatesFilter<"Reservation"> | string
    statutPasseport?: BoolWithAggregatesFilter<"Reservation"> | boolean
    statutVisa?: BoolWithAggregatesFilter<"Reservation"> | boolean
    statutHotel?: BoolWithAggregatesFilter<"Reservation"> | boolean
    statutVol?: BoolWithAggregatesFilter<"Reservation"> | boolean
    reservationDate?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    created_at?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Reservation"> | Date | string
    agentId?: IntNullableWithAggregatesFilter<"Reservation"> | number | null
  }

  export type FichierWhereInput = {
    AND?: FichierWhereInput | FichierWhereInput[]
    OR?: FichierWhereInput[]
    NOT?: FichierWhereInput | FichierWhereInput[]
    id?: IntFilter<"Fichier"> | number
    reservationId?: IntFilter<"Fichier"> | number
    fileName?: StringFilter<"Fichier"> | string
    storedName?: StringFilter<"Fichier"> | string
    fileType?: StringFilter<"Fichier"> | string
    fileCategory?: StringFilter<"Fichier"> | string
    filePath?: StringFilter<"Fichier"> | string
    uploaded_at?: DateTimeFilter<"Fichier"> | Date | string
    reservation?: XOR<ReservationRelationFilter, ReservationWhereInput>
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    expenses?: ExpenseListRelationFilter
  }

  export type FichierOrderByWithRelationInput = {
    id?: SortOrder
    reservationId?: SortOrder
    fileName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileCategory?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
    reservation?: ReservationOrderByWithRelationInput
    payment?: PaymentOrderByWithRelationInput
    expenses?: ExpenseOrderByRelationAggregateInput
  }

  export type FichierWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: FichierWhereInput | FichierWhereInput[]
    OR?: FichierWhereInput[]
    NOT?: FichierWhereInput | FichierWhereInput[]
    reservationId?: IntFilter<"Fichier"> | number
    fileName?: StringFilter<"Fichier"> | string
    storedName?: StringFilter<"Fichier"> | string
    fileType?: StringFilter<"Fichier"> | string
    fileCategory?: StringFilter<"Fichier"> | string
    filePath?: StringFilter<"Fichier"> | string
    uploaded_at?: DateTimeFilter<"Fichier"> | Date | string
    reservation?: XOR<ReservationRelationFilter, ReservationWhereInput>
    payment?: XOR<PaymentNullableRelationFilter, PaymentWhereInput> | null
    expenses?: ExpenseListRelationFilter
  }, "id">

  export type FichierOrderByWithAggregationInput = {
    id?: SortOrder
    reservationId?: SortOrder
    fileName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileCategory?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
    _count?: FichierCountOrderByAggregateInput
    _avg?: FichierAvgOrderByAggregateInput
    _max?: FichierMaxOrderByAggregateInput
    _min?: FichierMinOrderByAggregateInput
    _sum?: FichierSumOrderByAggregateInput
  }

  export type FichierScalarWhereWithAggregatesInput = {
    AND?: FichierScalarWhereWithAggregatesInput | FichierScalarWhereWithAggregatesInput[]
    OR?: FichierScalarWhereWithAggregatesInput[]
    NOT?: FichierScalarWhereWithAggregatesInput | FichierScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Fichier"> | number
    reservationId?: IntWithAggregatesFilter<"Fichier"> | number
    fileName?: StringWithAggregatesFilter<"Fichier"> | string
    storedName?: StringWithAggregatesFilter<"Fichier"> | string
    fileType?: StringWithAggregatesFilter<"Fichier"> | string
    fileCategory?: StringWithAggregatesFilter<"Fichier"> | string
    filePath?: StringWithAggregatesFilter<"Fichier"> | string
    uploaded_at?: DateTimeWithAggregatesFilter<"Fichier"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: IntFilter<"Payment"> | number
    reservationId?: IntFilter<"Payment"> | number
    agentId?: IntNullableFilter<"Payment"> | number | null
    amount?: FloatFilter<"Payment"> | number
    paymentMethod?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    fichierId?: IntNullableFilter<"Payment"> | number | null
    programId?: IntNullableFilter<"Payment"> | number | null
    fichier?: XOR<FichierNullableRelationFilter, FichierWhereInput> | null
    reservation?: XOR<ReservationRelationFilter, ReservationWhereInput>
    agent?: XOR<AgentNullableRelationFilter, AgentWhereInput> | null
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    reservationId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    fichierId?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    fichier?: FichierOrderByWithRelationInput
    reservation?: ReservationOrderByWithRelationInput
    agent?: AgentOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    fichierId?: number
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    reservationId?: IntFilter<"Payment"> | number
    agentId?: IntNullableFilter<"Payment"> | number | null
    amount?: FloatFilter<"Payment"> | number
    paymentMethod?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    programId?: IntNullableFilter<"Payment"> | number | null
    fichier?: XOR<FichierNullableRelationFilter, FichierWhereInput> | null
    reservation?: XOR<ReservationRelationFilter, ReservationWhereInput>
    agent?: XOR<AgentNullableRelationFilter, AgentWhereInput> | null
  }, "id" | "fichierId">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    reservationId?: SortOrder
    agentId?: SortOrderInput | SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    fichierId?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Payment"> | number
    reservationId?: IntWithAggregatesFilter<"Payment"> | number
    agentId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    amount?: FloatWithAggregatesFilter<"Payment"> | number
    paymentMethod?: StringWithAggregatesFilter<"Payment"> | string
    paymentDate?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    fichierId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
    programId?: IntNullableWithAggregatesFilter<"Payment"> | number | null
  }

  export type ExpenseWhereInput = {
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    id?: IntFilter<"Expense"> | number
    description?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    date?: DateTimeFilter<"Expense"> | Date | string
    type?: StringFilter<"Expense"> | string
    fichierId?: IntNullableFilter<"Expense"> | number | null
    programId?: IntNullableFilter<"Expense"> | number | null
    reservationId?: IntNullableFilter<"Expense"> | number | null
    program?: XOR<ProgramNullableRelationFilter, ProgramWhereInput> | null
    reservation?: XOR<ReservationNullableRelationFilter, ReservationWhereInput> | null
    fichier?: XOR<FichierNullableRelationFilter, FichierWhereInput> | null
  }

  export type ExpenseOrderByWithRelationInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    fichierId?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    reservationId?: SortOrderInput | SortOrder
    program?: ProgramOrderByWithRelationInput
    reservation?: ReservationOrderByWithRelationInput
    fichier?: FichierOrderByWithRelationInput
  }

  export type ExpenseWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: ExpenseWhereInput | ExpenseWhereInput[]
    OR?: ExpenseWhereInput[]
    NOT?: ExpenseWhereInput | ExpenseWhereInput[]
    description?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    date?: DateTimeFilter<"Expense"> | Date | string
    type?: StringFilter<"Expense"> | string
    fichierId?: IntNullableFilter<"Expense"> | number | null
    programId?: IntNullableFilter<"Expense"> | number | null
    reservationId?: IntNullableFilter<"Expense"> | number | null
    program?: XOR<ProgramNullableRelationFilter, ProgramWhereInput> | null
    reservation?: XOR<ReservationNullableRelationFilter, ReservationWhereInput> | null
    fichier?: XOR<FichierNullableRelationFilter, FichierWhereInput> | null
  }, "id">

  export type ExpenseOrderByWithAggregationInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    fichierId?: SortOrderInput | SortOrder
    programId?: SortOrderInput | SortOrder
    reservationId?: SortOrderInput | SortOrder
    _count?: ExpenseCountOrderByAggregateInput
    _avg?: ExpenseAvgOrderByAggregateInput
    _max?: ExpenseMaxOrderByAggregateInput
    _min?: ExpenseMinOrderByAggregateInput
    _sum?: ExpenseSumOrderByAggregateInput
  }

  export type ExpenseScalarWhereWithAggregatesInput = {
    AND?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    OR?: ExpenseScalarWhereWithAggregatesInput[]
    NOT?: ExpenseScalarWhereWithAggregatesInput | ExpenseScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Expense"> | number
    description?: StringWithAggregatesFilter<"Expense"> | string
    amount?: FloatWithAggregatesFilter<"Expense"> | number
    date?: DateTimeWithAggregatesFilter<"Expense"> | Date | string
    type?: StringWithAggregatesFilter<"Expense"> | string
    fichierId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    programId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
    reservationId?: IntNullableWithAggregatesFilter<"Expense"> | number | null
  }

  export type UserCreateInput = {
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUncheckedCreateInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserCreateManyInput = {
    id?: number
    email: string
    password: string
    name: string
    role?: $Enums.Role
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: EnumRoleFieldUpdateOperationsInput | $Enums.Role
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentCreateInput = {
    nom: string
    email?: string | null
    motDePasse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutAgentInput
    payments?: PaymentCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateInput = {
    id?: number
    nom: string
    email?: string | null
    motDePasse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutAgentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentUpdateInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    motDePasse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutAgentNestedInput
    payments?: PaymentUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    motDePasse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutAgentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type AgentCreateManyInput = {
    id?: number
    nom: string
    email?: string | null
    motDePasse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AgentUpdateManyMutationInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    motDePasse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AgentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    motDePasse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProgramCreateInput = {
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseCreateNestedManyWithoutProgramInput
    hotelsMadina?: ProgramHotelMadinaCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahCreateNestedManyWithoutProgramInput
    rooms?: RoomCreateNestedManyWithoutProgramInput
    reservations?: ReservationCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateInput = {
    id?: number
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseUncheckedCreateNestedManyWithoutProgramInput
    hotelsMadina?: ProgramHotelMadinaUncheckedCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedCreateNestedManyWithoutProgramInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProgramInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUpdateManyWithoutProgramNestedInput
    hotelsMadina?: ProgramHotelMadinaUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUpdateManyWithoutProgramNestedInput
    rooms?: RoomUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUncheckedUpdateManyWithoutProgramNestedInput
    hotelsMadina?: ProgramHotelMadinaUncheckedUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedUpdateManyWithoutProgramNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ProgramCreateManyInput = {
    id?: number
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
  }

  export type ProgramUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
  }

  export type ProgramUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
  }

  export type HotelCreateInput = {
    name: string
    city: $Enums.City
    programsMadina?: ProgramHotelMadinaCreateNestedManyWithoutHotelInput
    programsMakkah?: ProgramHotelMakkahCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateInput = {
    id?: number
    name: string
    city: $Enums.City
    programsMadina?: ProgramHotelMadinaUncheckedCreateNestedManyWithoutHotelInput
    programsMakkah?: ProgramHotelMakkahUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
    programsMadina?: ProgramHotelMadinaUpdateManyWithoutHotelNestedInput
    programsMakkah?: ProgramHotelMakkahUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
    programsMadina?: ProgramHotelMadinaUncheckedUpdateManyWithoutHotelNestedInput
    programsMakkah?: ProgramHotelMakkahUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type HotelCreateManyInput = {
    id?: number
    name: string
    city: $Enums.City
  }

  export type HotelUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
  }

  export type HotelUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
  }

  export type ProgramHotelMadinaCreateInput = {
    program: ProgramCreateNestedOneWithoutHotelsMadinaInput
    hotel: HotelCreateNestedOneWithoutProgramsMadinaInput
  }

  export type ProgramHotelMadinaUncheckedCreateInput = {
    id?: number
    programId: number
    hotelId: number
  }

  export type ProgramHotelMadinaUpdateInput = {
    program?: ProgramUpdateOneRequiredWithoutHotelsMadinaNestedInput
    hotel?: HotelUpdateOneRequiredWithoutProgramsMadinaNestedInput
  }

  export type ProgramHotelMadinaUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramHotelMadinaCreateManyInput = {
    id?: number
    programId: number
    hotelId: number
  }

  export type ProgramHotelMadinaUpdateManyMutationInput = {

  }

  export type ProgramHotelMadinaUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramHotelMakkahCreateInput = {
    program: ProgramCreateNestedOneWithoutHotelsMakkahInput
    hotel: HotelCreateNestedOneWithoutProgramsMakkahInput
  }

  export type ProgramHotelMakkahUncheckedCreateInput = {
    id?: number
    programId: number
    hotelId: number
  }

  export type ProgramHotelMakkahUpdateInput = {
    program?: ProgramUpdateOneRequiredWithoutHotelsMakkahNestedInput
    hotel?: HotelUpdateOneRequiredWithoutProgramsMakkahNestedInput
  }

  export type ProgramHotelMakkahUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramHotelMakkahCreateManyInput = {
    id?: number
    programId: number
    hotelId: number
  }

  export type ProgramHotelMakkahUpdateManyMutationInput = {

  }

  export type ProgramHotelMakkahUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomCreateInput = {
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation?: RoomCreatelisteIdsReservationInput | number[]
    created_at?: Date | string
    updated_at?: Date | string
    program: ProgramCreateNestedOneWithoutRoomsInput
    hotel: HotelCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateInput = {
    id?: number
    programId: number
    hotelId: number
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation?: RoomCreatelisteIdsReservationInput | number[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RoomUpdateInput = {
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutRoomsNestedInput
    hotel?: HotelUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomCreateManyInput = {
    id?: number
    programId: number
    hotelId: number
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation?: RoomCreatelisteIdsReservationInput | number[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RoomUpdateManyMutationInput = {
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationCreateInput = {
    firstName: string
    lastName: string
    phone: string
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    documents?: FichierCreateNestedManyWithoutReservationInput
    payments?: PaymentCreateNestedManyWithoutReservationInput
    expenses?: ExpenseCreateNestedManyWithoutReservationInput
    program: ProgramCreateNestedOneWithoutReservationsInput
    agent?: AgentCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateInput = {
    id?: number
    firstName: string
    lastName: string
    phone: string
    programId: number
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    agentId?: number | null
    documents?: FichierUncheckedCreateNestedManyWithoutReservationInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationUpdateInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FichierUpdateManyWithoutReservationNestedInput
    payments?: PaymentUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUpdateManyWithoutReservationNestedInput
    program?: ProgramUpdateOneRequiredWithoutReservationsNestedInput
    agent?: AgentUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    documents?: FichierUncheckedUpdateManyWithoutReservationNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationCreateManyInput = {
    id?: number
    firstName: string
    lastName: string
    phone: string
    programId: number
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    agentId?: number | null
  }

  export type ReservationUpdateManyMutationInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type FichierCreateInput = {
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
    reservation: ReservationCreateNestedOneWithoutDocumentsInput
    payment?: PaymentCreateNestedOneWithoutFichierInput
    expenses?: ExpenseCreateNestedManyWithoutFichierInput
  }

  export type FichierUncheckedCreateInput = {
    id?: number
    reservationId: number
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutFichierInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFichierInput
  }

  export type FichierUpdateInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reservation?: ReservationUpdateOneRequiredWithoutDocumentsNestedInput
    payment?: PaymentUpdateOneWithoutFichierNestedInput
    expenses?: ExpenseUpdateManyWithoutFichierNestedInput
  }

  export type FichierUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservationId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutFichierNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFichierNestedInput
  }

  export type FichierCreateManyInput = {
    id?: number
    reservationId: number
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
  }

  export type FichierUpdateManyMutationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FichierUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservationId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    programId?: number | null
    fichier?: FichierCreateNestedOneWithoutPaymentInput
    reservation: ReservationCreateNestedOneWithoutPaymentsInput
    agent?: AgentCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: number
    reservationId: number
    agentId?: number | null
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    fichierId?: number | null
    programId?: number | null
  }

  export type PaymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    fichier?: FichierUpdateOneWithoutPaymentNestedInput
    reservation?: ReservationUpdateOneRequiredWithoutPaymentsNestedInput
    agent?: AgentUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservationId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentCreateManyInput = {
    id?: number
    reservationId: number
    agentId?: number | null
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    fichierId?: number | null
    programId?: number | null
  }

  export type PaymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservationId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseCreateInput = {
    description: string
    amount: number
    date?: Date | string
    type: string
    program?: ProgramCreateNestedOneWithoutExpensesInput
    reservation?: ReservationCreateNestedOneWithoutExpensesInput
    fichier?: FichierCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateInput = {
    id?: number
    description: string
    amount: number
    date?: Date | string
    type: string
    fichierId?: number | null
    programId?: number | null
    reservationId?: number | null
  }

  export type ExpenseUpdateInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    program?: ProgramUpdateOneWithoutExpensesNestedInput
    reservation?: ReservationUpdateOneWithoutExpensesNestedInput
    fichier?: FichierUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    reservationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseCreateManyInput = {
    id?: number
    description: string
    amount: number
    date?: Date | string
    type: string
    fichierId?: number | null
    programId?: number | null
    reservationId?: number | null
  }

  export type ExpenseUpdateManyMutationInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
  }

  export type ExpenseUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    reservationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    name?: SortOrder
    role?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type ReservationListRelationFilter = {
    every?: ReservationWhereInput
    some?: ReservationWhereInput
    none?: ReservationWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ReservationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AgentCountOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type AgentMaxOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentMinOrderByAggregateInput = {
    id?: SortOrder
    nom?: SortOrder
    email?: SortOrder
    motDePasse?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AgentSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ExpenseListRelationFilter = {
    every?: ExpenseWhereInput
    some?: ExpenseWhereInput
    none?: ExpenseWhereInput
  }

  export type ProgramHotelMadinaListRelationFilter = {
    every?: ProgramHotelMadinaWhereInput
    some?: ProgramHotelMadinaWhereInput
    none?: ProgramHotelMadinaWhereInput
  }

  export type ProgramHotelMakkahListRelationFilter = {
    every?: ProgramHotelMakkahWhereInput
    some?: ProgramHotelMakkahWhereInput
    none?: ProgramHotelMakkahWhereInput
  }

  export type RoomListRelationFilter = {
    every?: RoomWhereInput
    some?: RoomWhereInput
    none?: RoomWhereInput
  }

  export type ExpenseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramHotelMadinaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramHotelMakkahOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProgramCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    visaDeadline?: SortOrder
    hotelDeadline?: SortOrder
    flightDeadline?: SortOrder
    passportDeadline?: SortOrder
    nbJoursMadina?: SortOrder
    nbJoursMakkah?: SortOrder
    exchange?: SortOrder
    prixAvionDH?: SortOrder
    prixVisaRiyal?: SortOrder
    profit?: SortOrder
  }

  export type ProgramAvgOrderByAggregateInput = {
    id?: SortOrder
    nbJoursMadina?: SortOrder
    nbJoursMakkah?: SortOrder
    exchange?: SortOrder
    prixAvionDH?: SortOrder
    prixVisaRiyal?: SortOrder
    profit?: SortOrder
  }

  export type ProgramMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    visaDeadline?: SortOrder
    hotelDeadline?: SortOrder
    flightDeadline?: SortOrder
    passportDeadline?: SortOrder
    nbJoursMadina?: SortOrder
    nbJoursMakkah?: SortOrder
    exchange?: SortOrder
    prixAvionDH?: SortOrder
    prixVisaRiyal?: SortOrder
    profit?: SortOrder
  }

  export type ProgramMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    created_at?: SortOrder
    visaDeadline?: SortOrder
    hotelDeadline?: SortOrder
    flightDeadline?: SortOrder
    passportDeadline?: SortOrder
    nbJoursMadina?: SortOrder
    nbJoursMakkah?: SortOrder
    exchange?: SortOrder
    prixAvionDH?: SortOrder
    prixVisaRiyal?: SortOrder
    profit?: SortOrder
  }

  export type ProgramSumOrderByAggregateInput = {
    id?: SortOrder
    nbJoursMadina?: SortOrder
    nbJoursMakkah?: SortOrder
    exchange?: SortOrder
    prixAvionDH?: SortOrder
    prixVisaRiyal?: SortOrder
    profit?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumCityFilter<$PrismaModel = never> = {
    equals?: $Enums.City | EnumCityFieldRefInput<$PrismaModel>
    in?: $Enums.City[] | ListEnumCityFieldRefInput<$PrismaModel>
    notIn?: $Enums.City[] | ListEnumCityFieldRefInput<$PrismaModel>
    not?: NestedEnumCityFilter<$PrismaModel> | $Enums.City
  }

  export type HotelNameCityCompoundUniqueInput = {
    name: string
    city: $Enums.City
  }

  export type HotelCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
  }

  export type HotelAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type HotelMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
  }

  export type HotelMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    city?: SortOrder
  }

  export type HotelSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type EnumCityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.City | EnumCityFieldRefInput<$PrismaModel>
    in?: $Enums.City[] | ListEnumCityFieldRefInput<$PrismaModel>
    notIn?: $Enums.City[] | ListEnumCityFieldRefInput<$PrismaModel>
    not?: NestedEnumCityWithAggregatesFilter<$PrismaModel> | $Enums.City
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCityFilter<$PrismaModel>
    _max?: NestedEnumCityFilter<$PrismaModel>
  }

  export type ProgramRelationFilter = {
    is?: ProgramWhereInput
    isNot?: ProgramWhereInput
  }

  export type HotelRelationFilter = {
    is?: HotelWhereInput
    isNot?: HotelWhereInput
  }

  export type ProgramHotelMadinaProgramIdHotelIdCompoundUniqueInput = {
    programId: number
    hotelId: number
  }

  export type ProgramHotelMadinaCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type ProgramHotelMadinaAvgOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type ProgramHotelMadinaMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type ProgramHotelMadinaMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type ProgramHotelMadinaSumOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type ProgramHotelMakkahProgramIdHotelIdCompoundUniqueInput = {
    programId: number
    hotelId: number
  }

  export type ProgramHotelMakkahCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type ProgramHotelMakkahAvgOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type ProgramHotelMakkahMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type ProgramHotelMakkahMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type ProgramHotelMakkahSumOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
  }

  export type EnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type IntNullableListFilter<$PrismaModel = never> = {
    equals?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    has?: number | IntFieldRefInput<$PrismaModel> | null
    hasEvery?: number[] | ListIntFieldRefInput<$PrismaModel>
    hasSome?: number[] | ListIntFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type RoomCountOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    nbrPlaceTotal?: SortOrder
    nbrPlaceRestantes?: SortOrder
    prixRoom?: SortOrder
    listeIdsReservation?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RoomAvgOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    nbrPlaceTotal?: SortOrder
    nbrPlaceRestantes?: SortOrder
    prixRoom?: SortOrder
    listeIdsReservation?: SortOrder
  }

  export type RoomMaxOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    nbrPlaceTotal?: SortOrder
    nbrPlaceRestantes?: SortOrder
    prixRoom?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RoomMinOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    nbrPlaceTotal?: SortOrder
    nbrPlaceRestantes?: SortOrder
    prixRoom?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type RoomSumOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    hotelId?: SortOrder
    nbrPlaceTotal?: SortOrder
    nbrPlaceRestantes?: SortOrder
    prixRoom?: SortOrder
    listeIdsReservation?: SortOrder
  }

  export type EnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type FichierListRelationFilter = {
    every?: FichierWhereInput
    some?: FichierWhereInput
    none?: FichierWhereInput
  }

  export type AgentNullableRelationFilter = {
    is?: AgentWhereInput | null
    isNot?: AgentWhereInput | null
  }

  export type FichierOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ReservationCountOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    programId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    hotelMadina?: SortOrder
    hotelMakkah?: SortOrder
    price?: SortOrder
    reduction?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    statutPasseport?: SortOrder
    statutVisa?: SortOrder
    statutHotel?: SortOrder
    statutVol?: SortOrder
    reservationDate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agentId?: SortOrder
  }

  export type ReservationAvgOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    price?: SortOrder
    reduction?: SortOrder
    paidAmount?: SortOrder
    agentId?: SortOrder
  }

  export type ReservationMaxOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    programId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    hotelMadina?: SortOrder
    hotelMakkah?: SortOrder
    price?: SortOrder
    reduction?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    statutPasseport?: SortOrder
    statutVisa?: SortOrder
    statutHotel?: SortOrder
    statutVol?: SortOrder
    reservationDate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agentId?: SortOrder
  }

  export type ReservationMinOrderByAggregateInput = {
    id?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    phone?: SortOrder
    programId?: SortOrder
    roomType?: SortOrder
    gender?: SortOrder
    hotelMadina?: SortOrder
    hotelMakkah?: SortOrder
    price?: SortOrder
    reduction?: SortOrder
    paidAmount?: SortOrder
    status?: SortOrder
    statutPasseport?: SortOrder
    statutVisa?: SortOrder
    statutHotel?: SortOrder
    statutVol?: SortOrder
    reservationDate?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    agentId?: SortOrder
  }

  export type ReservationSumOrderByAggregateInput = {
    id?: SortOrder
    programId?: SortOrder
    price?: SortOrder
    reduction?: SortOrder
    paidAmount?: SortOrder
    agentId?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type ReservationRelationFilter = {
    is?: ReservationWhereInput
    isNot?: ReservationWhereInput
  }

  export type PaymentNullableRelationFilter = {
    is?: PaymentWhereInput | null
    isNot?: PaymentWhereInput | null
  }

  export type FichierCountOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    fileName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileCategory?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
  }

  export type FichierAvgOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
  }

  export type FichierMaxOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    fileName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileCategory?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
  }

  export type FichierMinOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    fileName?: SortOrder
    storedName?: SortOrder
    fileType?: SortOrder
    fileCategory?: SortOrder
    filePath?: SortOrder
    uploaded_at?: SortOrder
  }

  export type FichierSumOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
  }

  export type FichierNullableRelationFilter = {
    is?: FichierWhereInput | null
    isNot?: FichierWhereInput | null
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    paymentMethod?: SortOrder
    paymentDate?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    id?: SortOrder
    reservationId?: SortOrder
    agentId?: SortOrder
    amount?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
  }

  export type ProgramNullableRelationFilter = {
    is?: ProgramWhereInput | null
    isNot?: ProgramWhereInput | null
  }

  export type ReservationNullableRelationFilter = {
    is?: ReservationWhereInput | null
    isNot?: ReservationWhereInput | null
  }

  export type ExpenseCountOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
    reservationId?: SortOrder
  }

  export type ExpenseAvgOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
    reservationId?: SortOrder
  }

  export type ExpenseMaxOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
    reservationId?: SortOrder
  }

  export type ExpenseMinOrderByAggregateInput = {
    id?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
    reservationId?: SortOrder
  }

  export type ExpenseSumOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    fichierId?: SortOrder
    programId?: SortOrder
    reservationId?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ReservationCreateNestedManyWithoutAgentInput = {
    create?: XOR<ReservationCreateWithoutAgentInput, ReservationUncheckedCreateWithoutAgentInput> | ReservationCreateWithoutAgentInput[] | ReservationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAgentInput | ReservationCreateOrConnectWithoutAgentInput[]
    createMany?: ReservationCreateManyAgentInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutAgentInput = {
    create?: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput> | PaymentCreateWithoutAgentInput[] | PaymentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAgentInput | PaymentCreateOrConnectWithoutAgentInput[]
    createMany?: PaymentCreateManyAgentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<ReservationCreateWithoutAgentInput, ReservationUncheckedCreateWithoutAgentInput> | ReservationCreateWithoutAgentInput[] | ReservationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAgentInput | ReservationCreateOrConnectWithoutAgentInput[]
    createMany?: ReservationCreateManyAgentInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutAgentInput = {
    create?: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput> | PaymentCreateWithoutAgentInput[] | PaymentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAgentInput | PaymentCreateOrConnectWithoutAgentInput[]
    createMany?: PaymentCreateManyAgentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type ReservationUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ReservationCreateWithoutAgentInput, ReservationUncheckedCreateWithoutAgentInput> | ReservationCreateWithoutAgentInput[] | ReservationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAgentInput | ReservationCreateOrConnectWithoutAgentInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutAgentInput | ReservationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ReservationCreateManyAgentInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutAgentInput | ReservationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutAgentInput | ReservationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput> | PaymentCreateWithoutAgentInput[] | PaymentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAgentInput | PaymentCreateOrConnectWithoutAgentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutAgentInput | PaymentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PaymentCreateManyAgentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutAgentInput | PaymentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutAgentInput | PaymentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<ReservationCreateWithoutAgentInput, ReservationUncheckedCreateWithoutAgentInput> | ReservationCreateWithoutAgentInput[] | ReservationUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutAgentInput | ReservationCreateOrConnectWithoutAgentInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutAgentInput | ReservationUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: ReservationCreateManyAgentInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutAgentInput | ReservationUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutAgentInput | ReservationUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutAgentNestedInput = {
    create?: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput> | PaymentCreateWithoutAgentInput[] | PaymentUncheckedCreateWithoutAgentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutAgentInput | PaymentCreateOrConnectWithoutAgentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutAgentInput | PaymentUpsertWithWhereUniqueWithoutAgentInput[]
    createMany?: PaymentCreateManyAgentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutAgentInput | PaymentUpdateWithWhereUniqueWithoutAgentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutAgentInput | PaymentUpdateManyWithWhereWithoutAgentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ExpenseCreateNestedManyWithoutProgramInput = {
    create?: XOR<ExpenseCreateWithoutProgramInput, ExpenseUncheckedCreateWithoutProgramInput> | ExpenseCreateWithoutProgramInput[] | ExpenseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutProgramInput | ExpenseCreateOrConnectWithoutProgramInput[]
    createMany?: ExpenseCreateManyProgramInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ProgramHotelMadinaCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramHotelMadinaCreateWithoutProgramInput, ProgramHotelMadinaUncheckedCreateWithoutProgramInput> | ProgramHotelMadinaCreateWithoutProgramInput[] | ProgramHotelMadinaUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramHotelMadinaCreateOrConnectWithoutProgramInput | ProgramHotelMadinaCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramHotelMadinaCreateManyProgramInputEnvelope
    connect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
  }

  export type ProgramHotelMakkahCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramHotelMakkahCreateWithoutProgramInput, ProgramHotelMakkahUncheckedCreateWithoutProgramInput> | ProgramHotelMakkahCreateWithoutProgramInput[] | ProgramHotelMakkahUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramHotelMakkahCreateOrConnectWithoutProgramInput | ProgramHotelMakkahCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramHotelMakkahCreateManyProgramInputEnvelope
    connect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutProgramInput = {
    create?: XOR<RoomCreateWithoutProgramInput, RoomUncheckedCreateWithoutProgramInput> | RoomCreateWithoutProgramInput[] | RoomUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutProgramInput | RoomCreateOrConnectWithoutProgramInput[]
    createMany?: RoomCreateManyProgramInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ReservationCreateNestedManyWithoutProgramInput = {
    create?: XOR<ReservationCreateWithoutProgramInput, ReservationUncheckedCreateWithoutProgramInput> | ReservationCreateWithoutProgramInput[] | ReservationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutProgramInput | ReservationCreateOrConnectWithoutProgramInput[]
    createMany?: ReservationCreateManyProgramInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ExpenseCreateWithoutProgramInput, ExpenseUncheckedCreateWithoutProgramInput> | ExpenseCreateWithoutProgramInput[] | ExpenseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutProgramInput | ExpenseCreateOrConnectWithoutProgramInput[]
    createMany?: ExpenseCreateManyProgramInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ProgramHotelMadinaUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramHotelMadinaCreateWithoutProgramInput, ProgramHotelMadinaUncheckedCreateWithoutProgramInput> | ProgramHotelMadinaCreateWithoutProgramInput[] | ProgramHotelMadinaUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramHotelMadinaCreateOrConnectWithoutProgramInput | ProgramHotelMadinaCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramHotelMadinaCreateManyProgramInputEnvelope
    connect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
  }

  export type ProgramHotelMakkahUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ProgramHotelMakkahCreateWithoutProgramInput, ProgramHotelMakkahUncheckedCreateWithoutProgramInput> | ProgramHotelMakkahCreateWithoutProgramInput[] | ProgramHotelMakkahUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramHotelMakkahCreateOrConnectWithoutProgramInput | ProgramHotelMakkahCreateOrConnectWithoutProgramInput[]
    createMany?: ProgramHotelMakkahCreateManyProgramInputEnvelope
    connect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<RoomCreateWithoutProgramInput, RoomUncheckedCreateWithoutProgramInput> | RoomCreateWithoutProgramInput[] | RoomUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutProgramInput | RoomCreateOrConnectWithoutProgramInput[]
    createMany?: RoomCreateManyProgramInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ReservationUncheckedCreateNestedManyWithoutProgramInput = {
    create?: XOR<ReservationCreateWithoutProgramInput, ReservationUncheckedCreateWithoutProgramInput> | ReservationCreateWithoutProgramInput[] | ReservationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutProgramInput | ReservationCreateOrConnectWithoutProgramInput[]
    createMany?: ReservationCreateManyProgramInputEnvelope
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type ExpenseUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ExpenseCreateWithoutProgramInput, ExpenseUncheckedCreateWithoutProgramInput> | ExpenseCreateWithoutProgramInput[] | ExpenseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutProgramInput | ExpenseCreateOrConnectWithoutProgramInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutProgramInput | ExpenseUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ExpenseCreateManyProgramInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutProgramInput | ExpenseUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutProgramInput | ExpenseUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ProgramHotelMadinaUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramHotelMadinaCreateWithoutProgramInput, ProgramHotelMadinaUncheckedCreateWithoutProgramInput> | ProgramHotelMadinaCreateWithoutProgramInput[] | ProgramHotelMadinaUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramHotelMadinaCreateOrConnectWithoutProgramInput | ProgramHotelMadinaCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramHotelMadinaUpsertWithWhereUniqueWithoutProgramInput | ProgramHotelMadinaUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramHotelMadinaCreateManyProgramInputEnvelope
    set?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    disconnect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    delete?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    connect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    update?: ProgramHotelMadinaUpdateWithWhereUniqueWithoutProgramInput | ProgramHotelMadinaUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramHotelMadinaUpdateManyWithWhereWithoutProgramInput | ProgramHotelMadinaUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramHotelMadinaScalarWhereInput | ProgramHotelMadinaScalarWhereInput[]
  }

  export type ProgramHotelMakkahUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramHotelMakkahCreateWithoutProgramInput, ProgramHotelMakkahUncheckedCreateWithoutProgramInput> | ProgramHotelMakkahCreateWithoutProgramInput[] | ProgramHotelMakkahUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramHotelMakkahCreateOrConnectWithoutProgramInput | ProgramHotelMakkahCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramHotelMakkahUpsertWithWhereUniqueWithoutProgramInput | ProgramHotelMakkahUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramHotelMakkahCreateManyProgramInputEnvelope
    set?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    disconnect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    delete?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    connect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    update?: ProgramHotelMakkahUpdateWithWhereUniqueWithoutProgramInput | ProgramHotelMakkahUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramHotelMakkahUpdateManyWithWhereWithoutProgramInput | ProgramHotelMakkahUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramHotelMakkahScalarWhereInput | ProgramHotelMakkahScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutProgramNestedInput = {
    create?: XOR<RoomCreateWithoutProgramInput, RoomUncheckedCreateWithoutProgramInput> | RoomCreateWithoutProgramInput[] | RoomUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutProgramInput | RoomCreateOrConnectWithoutProgramInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutProgramInput | RoomUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: RoomCreateManyProgramInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutProgramInput | RoomUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutProgramInput | RoomUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ReservationUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ReservationCreateWithoutProgramInput, ReservationUncheckedCreateWithoutProgramInput> | ReservationCreateWithoutProgramInput[] | ReservationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutProgramInput | ReservationCreateOrConnectWithoutProgramInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutProgramInput | ReservationUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ReservationCreateManyProgramInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutProgramInput | ReservationUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutProgramInput | ReservationUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ExpenseCreateWithoutProgramInput, ExpenseUncheckedCreateWithoutProgramInput> | ExpenseCreateWithoutProgramInput[] | ExpenseUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutProgramInput | ExpenseCreateOrConnectWithoutProgramInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutProgramInput | ExpenseUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ExpenseCreateManyProgramInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutProgramInput | ExpenseUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutProgramInput | ExpenseUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ProgramHotelMadinaUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramHotelMadinaCreateWithoutProgramInput, ProgramHotelMadinaUncheckedCreateWithoutProgramInput> | ProgramHotelMadinaCreateWithoutProgramInput[] | ProgramHotelMadinaUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramHotelMadinaCreateOrConnectWithoutProgramInput | ProgramHotelMadinaCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramHotelMadinaUpsertWithWhereUniqueWithoutProgramInput | ProgramHotelMadinaUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramHotelMadinaCreateManyProgramInputEnvelope
    set?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    disconnect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    delete?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    connect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    update?: ProgramHotelMadinaUpdateWithWhereUniqueWithoutProgramInput | ProgramHotelMadinaUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramHotelMadinaUpdateManyWithWhereWithoutProgramInput | ProgramHotelMadinaUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramHotelMadinaScalarWhereInput | ProgramHotelMadinaScalarWhereInput[]
  }

  export type ProgramHotelMakkahUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ProgramHotelMakkahCreateWithoutProgramInput, ProgramHotelMakkahUncheckedCreateWithoutProgramInput> | ProgramHotelMakkahCreateWithoutProgramInput[] | ProgramHotelMakkahUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ProgramHotelMakkahCreateOrConnectWithoutProgramInput | ProgramHotelMakkahCreateOrConnectWithoutProgramInput[]
    upsert?: ProgramHotelMakkahUpsertWithWhereUniqueWithoutProgramInput | ProgramHotelMakkahUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ProgramHotelMakkahCreateManyProgramInputEnvelope
    set?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    disconnect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    delete?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    connect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    update?: ProgramHotelMakkahUpdateWithWhereUniqueWithoutProgramInput | ProgramHotelMakkahUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ProgramHotelMakkahUpdateManyWithWhereWithoutProgramInput | ProgramHotelMakkahUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ProgramHotelMakkahScalarWhereInput | ProgramHotelMakkahScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<RoomCreateWithoutProgramInput, RoomUncheckedCreateWithoutProgramInput> | RoomCreateWithoutProgramInput[] | RoomUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutProgramInput | RoomCreateOrConnectWithoutProgramInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutProgramInput | RoomUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: RoomCreateManyProgramInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutProgramInput | RoomUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutProgramInput | RoomUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ReservationUncheckedUpdateManyWithoutProgramNestedInput = {
    create?: XOR<ReservationCreateWithoutProgramInput, ReservationUncheckedCreateWithoutProgramInput> | ReservationCreateWithoutProgramInput[] | ReservationUncheckedCreateWithoutProgramInput[]
    connectOrCreate?: ReservationCreateOrConnectWithoutProgramInput | ReservationCreateOrConnectWithoutProgramInput[]
    upsert?: ReservationUpsertWithWhereUniqueWithoutProgramInput | ReservationUpsertWithWhereUniqueWithoutProgramInput[]
    createMany?: ReservationCreateManyProgramInputEnvelope
    set?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    disconnect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    delete?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    connect?: ReservationWhereUniqueInput | ReservationWhereUniqueInput[]
    update?: ReservationUpdateWithWhereUniqueWithoutProgramInput | ReservationUpdateWithWhereUniqueWithoutProgramInput[]
    updateMany?: ReservationUpdateManyWithWhereWithoutProgramInput | ReservationUpdateManyWithWhereWithoutProgramInput[]
    deleteMany?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
  }

  export type ProgramHotelMadinaCreateNestedManyWithoutHotelInput = {
    create?: XOR<ProgramHotelMadinaCreateWithoutHotelInput, ProgramHotelMadinaUncheckedCreateWithoutHotelInput> | ProgramHotelMadinaCreateWithoutHotelInput[] | ProgramHotelMadinaUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ProgramHotelMadinaCreateOrConnectWithoutHotelInput | ProgramHotelMadinaCreateOrConnectWithoutHotelInput[]
    createMany?: ProgramHotelMadinaCreateManyHotelInputEnvelope
    connect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
  }

  export type ProgramHotelMakkahCreateNestedManyWithoutHotelInput = {
    create?: XOR<ProgramHotelMakkahCreateWithoutHotelInput, ProgramHotelMakkahUncheckedCreateWithoutHotelInput> | ProgramHotelMakkahCreateWithoutHotelInput[] | ProgramHotelMakkahUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ProgramHotelMakkahCreateOrConnectWithoutHotelInput | ProgramHotelMakkahCreateOrConnectWithoutHotelInput[]
    createMany?: ProgramHotelMakkahCreateManyHotelInputEnvelope
    connect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
  }

  export type RoomCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type ProgramHotelMadinaUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<ProgramHotelMadinaCreateWithoutHotelInput, ProgramHotelMadinaUncheckedCreateWithoutHotelInput> | ProgramHotelMadinaCreateWithoutHotelInput[] | ProgramHotelMadinaUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ProgramHotelMadinaCreateOrConnectWithoutHotelInput | ProgramHotelMadinaCreateOrConnectWithoutHotelInput[]
    createMany?: ProgramHotelMadinaCreateManyHotelInputEnvelope
    connect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
  }

  export type ProgramHotelMakkahUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<ProgramHotelMakkahCreateWithoutHotelInput, ProgramHotelMakkahUncheckedCreateWithoutHotelInput> | ProgramHotelMakkahCreateWithoutHotelInput[] | ProgramHotelMakkahUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ProgramHotelMakkahCreateOrConnectWithoutHotelInput | ProgramHotelMakkahCreateOrConnectWithoutHotelInput[]
    createMany?: ProgramHotelMakkahCreateManyHotelInputEnvelope
    connect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
  }

  export type RoomUncheckedCreateNestedManyWithoutHotelInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
  }

  export type EnumCityFieldUpdateOperationsInput = {
    set?: $Enums.City
  }

  export type ProgramHotelMadinaUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ProgramHotelMadinaCreateWithoutHotelInput, ProgramHotelMadinaUncheckedCreateWithoutHotelInput> | ProgramHotelMadinaCreateWithoutHotelInput[] | ProgramHotelMadinaUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ProgramHotelMadinaCreateOrConnectWithoutHotelInput | ProgramHotelMadinaCreateOrConnectWithoutHotelInput[]
    upsert?: ProgramHotelMadinaUpsertWithWhereUniqueWithoutHotelInput | ProgramHotelMadinaUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ProgramHotelMadinaCreateManyHotelInputEnvelope
    set?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    disconnect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    delete?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    connect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    update?: ProgramHotelMadinaUpdateWithWhereUniqueWithoutHotelInput | ProgramHotelMadinaUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ProgramHotelMadinaUpdateManyWithWhereWithoutHotelInput | ProgramHotelMadinaUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ProgramHotelMadinaScalarWhereInput | ProgramHotelMadinaScalarWhereInput[]
  }

  export type ProgramHotelMakkahUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ProgramHotelMakkahCreateWithoutHotelInput, ProgramHotelMakkahUncheckedCreateWithoutHotelInput> | ProgramHotelMakkahCreateWithoutHotelInput[] | ProgramHotelMakkahUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ProgramHotelMakkahCreateOrConnectWithoutHotelInput | ProgramHotelMakkahCreateOrConnectWithoutHotelInput[]
    upsert?: ProgramHotelMakkahUpsertWithWhereUniqueWithoutHotelInput | ProgramHotelMakkahUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ProgramHotelMakkahCreateManyHotelInputEnvelope
    set?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    disconnect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    delete?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    connect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    update?: ProgramHotelMakkahUpdateWithWhereUniqueWithoutHotelInput | ProgramHotelMakkahUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ProgramHotelMakkahUpdateManyWithWhereWithoutHotelInput | ProgramHotelMakkahUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ProgramHotelMakkahScalarWhereInput | ProgramHotelMakkahScalarWhereInput[]
  }

  export type RoomUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutHotelInput | RoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutHotelInput | RoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutHotelInput | RoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ProgramHotelMadinaUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ProgramHotelMadinaCreateWithoutHotelInput, ProgramHotelMadinaUncheckedCreateWithoutHotelInput> | ProgramHotelMadinaCreateWithoutHotelInput[] | ProgramHotelMadinaUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ProgramHotelMadinaCreateOrConnectWithoutHotelInput | ProgramHotelMadinaCreateOrConnectWithoutHotelInput[]
    upsert?: ProgramHotelMadinaUpsertWithWhereUniqueWithoutHotelInput | ProgramHotelMadinaUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ProgramHotelMadinaCreateManyHotelInputEnvelope
    set?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    disconnect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    delete?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    connect?: ProgramHotelMadinaWhereUniqueInput | ProgramHotelMadinaWhereUniqueInput[]
    update?: ProgramHotelMadinaUpdateWithWhereUniqueWithoutHotelInput | ProgramHotelMadinaUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ProgramHotelMadinaUpdateManyWithWhereWithoutHotelInput | ProgramHotelMadinaUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ProgramHotelMadinaScalarWhereInput | ProgramHotelMadinaScalarWhereInput[]
  }

  export type ProgramHotelMakkahUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<ProgramHotelMakkahCreateWithoutHotelInput, ProgramHotelMakkahUncheckedCreateWithoutHotelInput> | ProgramHotelMakkahCreateWithoutHotelInput[] | ProgramHotelMakkahUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: ProgramHotelMakkahCreateOrConnectWithoutHotelInput | ProgramHotelMakkahCreateOrConnectWithoutHotelInput[]
    upsert?: ProgramHotelMakkahUpsertWithWhereUniqueWithoutHotelInput | ProgramHotelMakkahUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: ProgramHotelMakkahCreateManyHotelInputEnvelope
    set?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    disconnect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    delete?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    connect?: ProgramHotelMakkahWhereUniqueInput | ProgramHotelMakkahWhereUniqueInput[]
    update?: ProgramHotelMakkahUpdateWithWhereUniqueWithoutHotelInput | ProgramHotelMakkahUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: ProgramHotelMakkahUpdateManyWithWhereWithoutHotelInput | ProgramHotelMakkahUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: ProgramHotelMakkahScalarWhereInput | ProgramHotelMakkahScalarWhereInput[]
  }

  export type RoomUncheckedUpdateManyWithoutHotelNestedInput = {
    create?: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput> | RoomCreateWithoutHotelInput[] | RoomUncheckedCreateWithoutHotelInput[]
    connectOrCreate?: RoomCreateOrConnectWithoutHotelInput | RoomCreateOrConnectWithoutHotelInput[]
    upsert?: RoomUpsertWithWhereUniqueWithoutHotelInput | RoomUpsertWithWhereUniqueWithoutHotelInput[]
    createMany?: RoomCreateManyHotelInputEnvelope
    set?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    disconnect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    delete?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    connect?: RoomWhereUniqueInput | RoomWhereUniqueInput[]
    update?: RoomUpdateWithWhereUniqueWithoutHotelInput | RoomUpdateWithWhereUniqueWithoutHotelInput[]
    updateMany?: RoomUpdateManyWithWhereWithoutHotelInput | RoomUpdateManyWithWhereWithoutHotelInput[]
    deleteMany?: RoomScalarWhereInput | RoomScalarWhereInput[]
  }

  export type ProgramCreateNestedOneWithoutHotelsMadinaInput = {
    create?: XOR<ProgramCreateWithoutHotelsMadinaInput, ProgramUncheckedCreateWithoutHotelsMadinaInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutHotelsMadinaInput
    connect?: ProgramWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutProgramsMadinaInput = {
    create?: XOR<HotelCreateWithoutProgramsMadinaInput, HotelUncheckedCreateWithoutProgramsMadinaInput>
    connectOrCreate?: HotelCreateOrConnectWithoutProgramsMadinaInput
    connect?: HotelWhereUniqueInput
  }

  export type ProgramUpdateOneRequiredWithoutHotelsMadinaNestedInput = {
    create?: XOR<ProgramCreateWithoutHotelsMadinaInput, ProgramUncheckedCreateWithoutHotelsMadinaInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutHotelsMadinaInput
    upsert?: ProgramUpsertWithoutHotelsMadinaInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutHotelsMadinaInput, ProgramUpdateWithoutHotelsMadinaInput>, ProgramUncheckedUpdateWithoutHotelsMadinaInput>
  }

  export type HotelUpdateOneRequiredWithoutProgramsMadinaNestedInput = {
    create?: XOR<HotelCreateWithoutProgramsMadinaInput, HotelUncheckedCreateWithoutProgramsMadinaInput>
    connectOrCreate?: HotelCreateOrConnectWithoutProgramsMadinaInput
    upsert?: HotelUpsertWithoutProgramsMadinaInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutProgramsMadinaInput, HotelUpdateWithoutProgramsMadinaInput>, HotelUncheckedUpdateWithoutProgramsMadinaInput>
  }

  export type ProgramCreateNestedOneWithoutHotelsMakkahInput = {
    create?: XOR<ProgramCreateWithoutHotelsMakkahInput, ProgramUncheckedCreateWithoutHotelsMakkahInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutHotelsMakkahInput
    connect?: ProgramWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutProgramsMakkahInput = {
    create?: XOR<HotelCreateWithoutProgramsMakkahInput, HotelUncheckedCreateWithoutProgramsMakkahInput>
    connectOrCreate?: HotelCreateOrConnectWithoutProgramsMakkahInput
    connect?: HotelWhereUniqueInput
  }

  export type ProgramUpdateOneRequiredWithoutHotelsMakkahNestedInput = {
    create?: XOR<ProgramCreateWithoutHotelsMakkahInput, ProgramUncheckedCreateWithoutHotelsMakkahInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutHotelsMakkahInput
    upsert?: ProgramUpsertWithoutHotelsMakkahInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutHotelsMakkahInput, ProgramUpdateWithoutHotelsMakkahInput>, ProgramUncheckedUpdateWithoutHotelsMakkahInput>
  }

  export type HotelUpdateOneRequiredWithoutProgramsMakkahNestedInput = {
    create?: XOR<HotelCreateWithoutProgramsMakkahInput, HotelUncheckedCreateWithoutProgramsMakkahInput>
    connectOrCreate?: HotelCreateOrConnectWithoutProgramsMakkahInput
    upsert?: HotelUpsertWithoutProgramsMakkahInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutProgramsMakkahInput, HotelUpdateWithoutProgramsMakkahInput>, HotelUncheckedUpdateWithoutProgramsMakkahInput>
  }

  export type RoomCreatelisteIdsReservationInput = {
    set: number[]
  }

  export type ProgramCreateNestedOneWithoutRoomsInput = {
    create?: XOR<ProgramCreateWithoutRoomsInput, ProgramUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutRoomsInput
    connect?: ProgramWhereUniqueInput
  }

  export type HotelCreateNestedOneWithoutRoomsInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    connect?: HotelWhereUniqueInput
  }

  export type EnumRoomTypeFieldUpdateOperationsInput = {
    set?: $Enums.RoomType
  }

  export type RoomUpdatelisteIdsReservationInput = {
    set?: number[]
    push?: number | number[]
  }

  export type ProgramUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<ProgramCreateWithoutRoomsInput, ProgramUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutRoomsInput
    upsert?: ProgramUpsertWithoutRoomsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutRoomsInput, ProgramUpdateWithoutRoomsInput>, ProgramUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelUpdateOneRequiredWithoutRoomsNestedInput = {
    create?: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    connectOrCreate?: HotelCreateOrConnectWithoutRoomsInput
    upsert?: HotelUpsertWithoutRoomsInput
    connect?: HotelWhereUniqueInput
    update?: XOR<XOR<HotelUpdateToOneWithWhereWithoutRoomsInput, HotelUpdateWithoutRoomsInput>, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type FichierCreateNestedManyWithoutReservationInput = {
    create?: XOR<FichierCreateWithoutReservationInput, FichierUncheckedCreateWithoutReservationInput> | FichierCreateWithoutReservationInput[] | FichierUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: FichierCreateOrConnectWithoutReservationInput | FichierCreateOrConnectWithoutReservationInput[]
    createMany?: FichierCreateManyReservationInputEnvelope
    connect?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutReservationInput = {
    create?: XOR<PaymentCreateWithoutReservationInput, PaymentUncheckedCreateWithoutReservationInput> | PaymentCreateWithoutReservationInput[] | PaymentUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReservationInput | PaymentCreateOrConnectWithoutReservationInput[]
    createMany?: PaymentCreateManyReservationInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ExpenseCreateNestedManyWithoutReservationInput = {
    create?: XOR<ExpenseCreateWithoutReservationInput, ExpenseUncheckedCreateWithoutReservationInput> | ExpenseCreateWithoutReservationInput[] | ExpenseUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutReservationInput | ExpenseCreateOrConnectWithoutReservationInput[]
    createMany?: ExpenseCreateManyReservationInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ProgramCreateNestedOneWithoutReservationsInput = {
    create?: XOR<ProgramCreateWithoutReservationsInput, ProgramUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutReservationsInput
    connect?: ProgramWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutReservationsInput = {
    create?: XOR<AgentCreateWithoutReservationsInput, AgentUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutReservationsInput
    connect?: AgentWhereUniqueInput
  }

  export type FichierUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<FichierCreateWithoutReservationInput, FichierUncheckedCreateWithoutReservationInput> | FichierCreateWithoutReservationInput[] | FichierUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: FichierCreateOrConnectWithoutReservationInput | FichierCreateOrConnectWithoutReservationInput[]
    createMany?: FichierCreateManyReservationInputEnvelope
    connect?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<PaymentCreateWithoutReservationInput, PaymentUncheckedCreateWithoutReservationInput> | PaymentCreateWithoutReservationInput[] | PaymentUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReservationInput | PaymentCreateOrConnectWithoutReservationInput[]
    createMany?: PaymentCreateManyReservationInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ExpenseUncheckedCreateNestedManyWithoutReservationInput = {
    create?: XOR<ExpenseCreateWithoutReservationInput, ExpenseUncheckedCreateWithoutReservationInput> | ExpenseCreateWithoutReservationInput[] | ExpenseUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutReservationInput | ExpenseCreateOrConnectWithoutReservationInput[]
    createMany?: ExpenseCreateManyReservationInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type FichierUpdateManyWithoutReservationNestedInput = {
    create?: XOR<FichierCreateWithoutReservationInput, FichierUncheckedCreateWithoutReservationInput> | FichierCreateWithoutReservationInput[] | FichierUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: FichierCreateOrConnectWithoutReservationInput | FichierCreateOrConnectWithoutReservationInput[]
    upsert?: FichierUpsertWithWhereUniqueWithoutReservationInput | FichierUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: FichierCreateManyReservationInputEnvelope
    set?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
    disconnect?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
    delete?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
    connect?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
    update?: FichierUpdateWithWhereUniqueWithoutReservationInput | FichierUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: FichierUpdateManyWithWhereWithoutReservationInput | FichierUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: FichierScalarWhereInput | FichierScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutReservationNestedInput = {
    create?: XOR<PaymentCreateWithoutReservationInput, PaymentUncheckedCreateWithoutReservationInput> | PaymentCreateWithoutReservationInput[] | PaymentUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReservationInput | PaymentCreateOrConnectWithoutReservationInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReservationInput | PaymentUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: PaymentCreateManyReservationInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReservationInput | PaymentUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReservationInput | PaymentUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ExpenseUpdateManyWithoutReservationNestedInput = {
    create?: XOR<ExpenseCreateWithoutReservationInput, ExpenseUncheckedCreateWithoutReservationInput> | ExpenseCreateWithoutReservationInput[] | ExpenseUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutReservationInput | ExpenseCreateOrConnectWithoutReservationInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutReservationInput | ExpenseUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: ExpenseCreateManyReservationInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutReservationInput | ExpenseUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutReservationInput | ExpenseUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ProgramUpdateOneRequiredWithoutReservationsNestedInput = {
    create?: XOR<ProgramCreateWithoutReservationsInput, ProgramUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutReservationsInput
    upsert?: ProgramUpsertWithoutReservationsInput
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutReservationsInput, ProgramUpdateWithoutReservationsInput>, ProgramUncheckedUpdateWithoutReservationsInput>
  }

  export type AgentUpdateOneWithoutReservationsNestedInput = {
    create?: XOR<AgentCreateWithoutReservationsInput, AgentUncheckedCreateWithoutReservationsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutReservationsInput
    upsert?: AgentUpsertWithoutReservationsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutReservationsInput, AgentUpdateWithoutReservationsInput>, AgentUncheckedUpdateWithoutReservationsInput>
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FichierUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<FichierCreateWithoutReservationInput, FichierUncheckedCreateWithoutReservationInput> | FichierCreateWithoutReservationInput[] | FichierUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: FichierCreateOrConnectWithoutReservationInput | FichierCreateOrConnectWithoutReservationInput[]
    upsert?: FichierUpsertWithWhereUniqueWithoutReservationInput | FichierUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: FichierCreateManyReservationInputEnvelope
    set?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
    disconnect?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
    delete?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
    connect?: FichierWhereUniqueInput | FichierWhereUniqueInput[]
    update?: FichierUpdateWithWhereUniqueWithoutReservationInput | FichierUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: FichierUpdateManyWithWhereWithoutReservationInput | FichierUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: FichierScalarWhereInput | FichierScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<PaymentCreateWithoutReservationInput, PaymentUncheckedCreateWithoutReservationInput> | PaymentCreateWithoutReservationInput[] | PaymentUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutReservationInput | PaymentCreateOrConnectWithoutReservationInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutReservationInput | PaymentUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: PaymentCreateManyReservationInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutReservationInput | PaymentUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutReservationInput | PaymentUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ExpenseUncheckedUpdateManyWithoutReservationNestedInput = {
    create?: XOR<ExpenseCreateWithoutReservationInput, ExpenseUncheckedCreateWithoutReservationInput> | ExpenseCreateWithoutReservationInput[] | ExpenseUncheckedCreateWithoutReservationInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutReservationInput | ExpenseCreateOrConnectWithoutReservationInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutReservationInput | ExpenseUpsertWithWhereUniqueWithoutReservationInput[]
    createMany?: ExpenseCreateManyReservationInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutReservationInput | ExpenseUpdateWithWhereUniqueWithoutReservationInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutReservationInput | ExpenseUpdateManyWithWhereWithoutReservationInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type ReservationCreateNestedOneWithoutDocumentsInput = {
    create?: XOR<ReservationCreateWithoutDocumentsInput, ReservationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutDocumentsInput
    connect?: ReservationWhereUniqueInput
  }

  export type PaymentCreateNestedOneWithoutFichierInput = {
    create?: XOR<PaymentCreateWithoutFichierInput, PaymentUncheckedCreateWithoutFichierInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutFichierInput
    connect?: PaymentWhereUniqueInput
  }

  export type ExpenseCreateNestedManyWithoutFichierInput = {
    create?: XOR<ExpenseCreateWithoutFichierInput, ExpenseUncheckedCreateWithoutFichierInput> | ExpenseCreateWithoutFichierInput[] | ExpenseUncheckedCreateWithoutFichierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFichierInput | ExpenseCreateOrConnectWithoutFichierInput[]
    createMany?: ExpenseCreateManyFichierInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedOneWithoutFichierInput = {
    create?: XOR<PaymentCreateWithoutFichierInput, PaymentUncheckedCreateWithoutFichierInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutFichierInput
    connect?: PaymentWhereUniqueInput
  }

  export type ExpenseUncheckedCreateNestedManyWithoutFichierInput = {
    create?: XOR<ExpenseCreateWithoutFichierInput, ExpenseUncheckedCreateWithoutFichierInput> | ExpenseCreateWithoutFichierInput[] | ExpenseUncheckedCreateWithoutFichierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFichierInput | ExpenseCreateOrConnectWithoutFichierInput[]
    createMany?: ExpenseCreateManyFichierInputEnvelope
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
  }

  export type ReservationUpdateOneRequiredWithoutDocumentsNestedInput = {
    create?: XOR<ReservationCreateWithoutDocumentsInput, ReservationUncheckedCreateWithoutDocumentsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutDocumentsInput
    upsert?: ReservationUpsertWithoutDocumentsInput
    connect?: ReservationWhereUniqueInput
    update?: XOR<XOR<ReservationUpdateToOneWithWhereWithoutDocumentsInput, ReservationUpdateWithoutDocumentsInput>, ReservationUncheckedUpdateWithoutDocumentsInput>
  }

  export type PaymentUpdateOneWithoutFichierNestedInput = {
    create?: XOR<PaymentCreateWithoutFichierInput, PaymentUncheckedCreateWithoutFichierInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutFichierInput
    upsert?: PaymentUpsertWithoutFichierInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutFichierInput, PaymentUpdateWithoutFichierInput>, PaymentUncheckedUpdateWithoutFichierInput>
  }

  export type ExpenseUpdateManyWithoutFichierNestedInput = {
    create?: XOR<ExpenseCreateWithoutFichierInput, ExpenseUncheckedCreateWithoutFichierInput> | ExpenseCreateWithoutFichierInput[] | ExpenseUncheckedCreateWithoutFichierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFichierInput | ExpenseCreateOrConnectWithoutFichierInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutFichierInput | ExpenseUpsertWithWhereUniqueWithoutFichierInput[]
    createMany?: ExpenseCreateManyFichierInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutFichierInput | ExpenseUpdateWithWhereUniqueWithoutFichierInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutFichierInput | ExpenseUpdateManyWithWhereWithoutFichierInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateOneWithoutFichierNestedInput = {
    create?: XOR<PaymentCreateWithoutFichierInput, PaymentUncheckedCreateWithoutFichierInput>
    connectOrCreate?: PaymentCreateOrConnectWithoutFichierInput
    upsert?: PaymentUpsertWithoutFichierInput
    disconnect?: PaymentWhereInput | boolean
    delete?: PaymentWhereInput | boolean
    connect?: PaymentWhereUniqueInput
    update?: XOR<XOR<PaymentUpdateToOneWithWhereWithoutFichierInput, PaymentUpdateWithoutFichierInput>, PaymentUncheckedUpdateWithoutFichierInput>
  }

  export type ExpenseUncheckedUpdateManyWithoutFichierNestedInput = {
    create?: XOR<ExpenseCreateWithoutFichierInput, ExpenseUncheckedCreateWithoutFichierInput> | ExpenseCreateWithoutFichierInput[] | ExpenseUncheckedCreateWithoutFichierInput[]
    connectOrCreate?: ExpenseCreateOrConnectWithoutFichierInput | ExpenseCreateOrConnectWithoutFichierInput[]
    upsert?: ExpenseUpsertWithWhereUniqueWithoutFichierInput | ExpenseUpsertWithWhereUniqueWithoutFichierInput[]
    createMany?: ExpenseCreateManyFichierInputEnvelope
    set?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    disconnect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    delete?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    connect?: ExpenseWhereUniqueInput | ExpenseWhereUniqueInput[]
    update?: ExpenseUpdateWithWhereUniqueWithoutFichierInput | ExpenseUpdateWithWhereUniqueWithoutFichierInput[]
    updateMany?: ExpenseUpdateManyWithWhereWithoutFichierInput | ExpenseUpdateManyWithWhereWithoutFichierInput[]
    deleteMany?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
  }

  export type FichierCreateNestedOneWithoutPaymentInput = {
    create?: XOR<FichierCreateWithoutPaymentInput, FichierUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: FichierCreateOrConnectWithoutPaymentInput
    connect?: FichierWhereUniqueInput
  }

  export type ReservationCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<ReservationCreateWithoutPaymentsInput, ReservationUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutPaymentsInput
    connect?: ReservationWhereUniqueInput
  }

  export type AgentCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<AgentCreateWithoutPaymentsInput, AgentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPaymentsInput
    connect?: AgentWhereUniqueInput
  }

  export type FichierUpdateOneWithoutPaymentNestedInput = {
    create?: XOR<FichierCreateWithoutPaymentInput, FichierUncheckedCreateWithoutPaymentInput>
    connectOrCreate?: FichierCreateOrConnectWithoutPaymentInput
    upsert?: FichierUpsertWithoutPaymentInput
    disconnect?: FichierWhereInput | boolean
    delete?: FichierWhereInput | boolean
    connect?: FichierWhereUniqueInput
    update?: XOR<XOR<FichierUpdateToOneWithWhereWithoutPaymentInput, FichierUpdateWithoutPaymentInput>, FichierUncheckedUpdateWithoutPaymentInput>
  }

  export type ReservationUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<ReservationCreateWithoutPaymentsInput, ReservationUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutPaymentsInput
    upsert?: ReservationUpsertWithoutPaymentsInput
    connect?: ReservationWhereUniqueInput
    update?: XOR<XOR<ReservationUpdateToOneWithWhereWithoutPaymentsInput, ReservationUpdateWithoutPaymentsInput>, ReservationUncheckedUpdateWithoutPaymentsInput>
  }

  export type AgentUpdateOneWithoutPaymentsNestedInput = {
    create?: XOR<AgentCreateWithoutPaymentsInput, AgentUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: AgentCreateOrConnectWithoutPaymentsInput
    upsert?: AgentUpsertWithoutPaymentsInput
    disconnect?: AgentWhereInput | boolean
    delete?: AgentWhereInput | boolean
    connect?: AgentWhereUniqueInput
    update?: XOR<XOR<AgentUpdateToOneWithWhereWithoutPaymentsInput, AgentUpdateWithoutPaymentsInput>, AgentUncheckedUpdateWithoutPaymentsInput>
  }

  export type ProgramCreateNestedOneWithoutExpensesInput = {
    create?: XOR<ProgramCreateWithoutExpensesInput, ProgramUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutExpensesInput
    connect?: ProgramWhereUniqueInput
  }

  export type ReservationCreateNestedOneWithoutExpensesInput = {
    create?: XOR<ReservationCreateWithoutExpensesInput, ReservationUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutExpensesInput
    connect?: ReservationWhereUniqueInput
  }

  export type FichierCreateNestedOneWithoutExpensesInput = {
    create?: XOR<FichierCreateWithoutExpensesInput, FichierUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: FichierCreateOrConnectWithoutExpensesInput
    connect?: FichierWhereUniqueInput
  }

  export type ProgramUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<ProgramCreateWithoutExpensesInput, ProgramUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ProgramCreateOrConnectWithoutExpensesInput
    upsert?: ProgramUpsertWithoutExpensesInput
    disconnect?: ProgramWhereInput | boolean
    delete?: ProgramWhereInput | boolean
    connect?: ProgramWhereUniqueInput
    update?: XOR<XOR<ProgramUpdateToOneWithWhereWithoutExpensesInput, ProgramUpdateWithoutExpensesInput>, ProgramUncheckedUpdateWithoutExpensesInput>
  }

  export type ReservationUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<ReservationCreateWithoutExpensesInput, ReservationUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: ReservationCreateOrConnectWithoutExpensesInput
    upsert?: ReservationUpsertWithoutExpensesInput
    disconnect?: ReservationWhereInput | boolean
    delete?: ReservationWhereInput | boolean
    connect?: ReservationWhereUniqueInput
    update?: XOR<XOR<ReservationUpdateToOneWithWhereWithoutExpensesInput, ReservationUpdateWithoutExpensesInput>, ReservationUncheckedUpdateWithoutExpensesInput>
  }

  export type FichierUpdateOneWithoutExpensesNestedInput = {
    create?: XOR<FichierCreateWithoutExpensesInput, FichierUncheckedCreateWithoutExpensesInput>
    connectOrCreate?: FichierCreateOrConnectWithoutExpensesInput
    upsert?: FichierUpsertWithoutExpensesInput
    disconnect?: FichierWhereInput | boolean
    delete?: FichierWhereInput | boolean
    connect?: FichierWhereUniqueInput
    update?: XOR<XOR<FichierUpdateToOneWithWhereWithoutExpensesInput, FichierUpdateWithoutExpensesInput>, FichierUncheckedUpdateWithoutExpensesInput>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleFilter<$PrismaModel> | $Enums.Role
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel>
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumRoleWithAggregatesFilter<$PrismaModel> | $Enums.Role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoleFilter<$PrismaModel>
    _max?: NestedEnumRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumCityFilter<$PrismaModel = never> = {
    equals?: $Enums.City | EnumCityFieldRefInput<$PrismaModel>
    in?: $Enums.City[] | ListEnumCityFieldRefInput<$PrismaModel>
    notIn?: $Enums.City[] | ListEnumCityFieldRefInput<$PrismaModel>
    not?: NestedEnumCityFilter<$PrismaModel> | $Enums.City
  }

  export type NestedEnumCityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.City | EnumCityFieldRefInput<$PrismaModel>
    in?: $Enums.City[] | ListEnumCityFieldRefInput<$PrismaModel>
    notIn?: $Enums.City[] | ListEnumCityFieldRefInput<$PrismaModel>
    not?: NestedEnumCityWithAggregatesFilter<$PrismaModel> | $Enums.City
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumCityFilter<$PrismaModel>
    _max?: NestedEnumCityFilter<$PrismaModel>
  }

  export type NestedEnumRoomTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeFilter<$PrismaModel> | $Enums.RoomType
  }

  export type NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RoomType | EnumRoomTypeFieldRefInput<$PrismaModel>
    in?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.RoomType[] | ListEnumRoomTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumRoomTypeWithAggregatesFilter<$PrismaModel> | $Enums.RoomType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRoomTypeFilter<$PrismaModel>
    _max?: NestedEnumRoomTypeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type ReservationCreateWithoutAgentInput = {
    firstName: string
    lastName: string
    phone: string
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    documents?: FichierCreateNestedManyWithoutReservationInput
    payments?: PaymentCreateNestedManyWithoutReservationInput
    expenses?: ExpenseCreateNestedManyWithoutReservationInput
    program: ProgramCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutAgentInput = {
    id?: number
    firstName: string
    lastName: string
    phone: string
    programId: number
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    documents?: FichierUncheckedCreateNestedManyWithoutReservationInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutAgentInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutAgentInput, ReservationUncheckedCreateWithoutAgentInput>
  }

  export type ReservationCreateManyAgentInputEnvelope = {
    data: ReservationCreateManyAgentInput | ReservationCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutAgentInput = {
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    programId?: number | null
    fichier?: FichierCreateNestedOneWithoutPaymentInput
    reservation: ReservationCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutAgentInput = {
    id?: number
    reservationId: number
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    fichierId?: number | null
    programId?: number | null
  }

  export type PaymentCreateOrConnectWithoutAgentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput>
  }

  export type PaymentCreateManyAgentInputEnvelope = {
    data: PaymentCreateManyAgentInput | PaymentCreateManyAgentInput[]
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithWhereUniqueWithoutAgentInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutAgentInput, ReservationUncheckedUpdateWithoutAgentInput>
    create: XOR<ReservationCreateWithoutAgentInput, ReservationUncheckedCreateWithoutAgentInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutAgentInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutAgentInput, ReservationUncheckedUpdateWithoutAgentInput>
  }

  export type ReservationUpdateManyWithWhereWithoutAgentInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutAgentInput>
  }

  export type ReservationScalarWhereInput = {
    AND?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    OR?: ReservationScalarWhereInput[]
    NOT?: ReservationScalarWhereInput | ReservationScalarWhereInput[]
    id?: IntFilter<"Reservation"> | number
    firstName?: StringFilter<"Reservation"> | string
    lastName?: StringFilter<"Reservation"> | string
    phone?: StringFilter<"Reservation"> | string
    programId?: IntFilter<"Reservation"> | number
    roomType?: EnumRoomTypeFilter<"Reservation"> | $Enums.RoomType
    gender?: StringFilter<"Reservation"> | string
    hotelMadina?: StringNullableFilter<"Reservation"> | string | null
    hotelMakkah?: StringNullableFilter<"Reservation"> | string | null
    price?: FloatFilter<"Reservation"> | number
    reduction?: FloatFilter<"Reservation"> | number
    paidAmount?: FloatFilter<"Reservation"> | number
    status?: StringFilter<"Reservation"> | string
    statutPasseport?: BoolFilter<"Reservation"> | boolean
    statutVisa?: BoolFilter<"Reservation"> | boolean
    statutHotel?: BoolFilter<"Reservation"> | boolean
    statutVol?: BoolFilter<"Reservation"> | boolean
    reservationDate?: DateTimeFilter<"Reservation"> | Date | string
    created_at?: DateTimeFilter<"Reservation"> | Date | string
    updated_at?: DateTimeFilter<"Reservation"> | Date | string
    agentId?: IntNullableFilter<"Reservation"> | number | null
  }

  export type PaymentUpsertWithWhereUniqueWithoutAgentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutAgentInput, PaymentUncheckedUpdateWithoutAgentInput>
    create: XOR<PaymentCreateWithoutAgentInput, PaymentUncheckedCreateWithoutAgentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutAgentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutAgentInput, PaymentUncheckedUpdateWithoutAgentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutAgentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutAgentInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: IntFilter<"Payment"> | number
    reservationId?: IntFilter<"Payment"> | number
    agentId?: IntNullableFilter<"Payment"> | number | null
    amount?: FloatFilter<"Payment"> | number
    paymentMethod?: StringFilter<"Payment"> | string
    paymentDate?: DateTimeFilter<"Payment"> | Date | string
    fichierId?: IntNullableFilter<"Payment"> | number | null
    programId?: IntNullableFilter<"Payment"> | number | null
  }

  export type ExpenseCreateWithoutProgramInput = {
    description: string
    amount: number
    date?: Date | string
    type: string
    reservation?: ReservationCreateNestedOneWithoutExpensesInput
    fichier?: FichierCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutProgramInput = {
    id?: number
    description: string
    amount: number
    date?: Date | string
    type: string
    fichierId?: number | null
    reservationId?: number | null
  }

  export type ExpenseCreateOrConnectWithoutProgramInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutProgramInput, ExpenseUncheckedCreateWithoutProgramInput>
  }

  export type ExpenseCreateManyProgramInputEnvelope = {
    data: ExpenseCreateManyProgramInput | ExpenseCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ProgramHotelMadinaCreateWithoutProgramInput = {
    hotel: HotelCreateNestedOneWithoutProgramsMadinaInput
  }

  export type ProgramHotelMadinaUncheckedCreateWithoutProgramInput = {
    id?: number
    hotelId: number
  }

  export type ProgramHotelMadinaCreateOrConnectWithoutProgramInput = {
    where: ProgramHotelMadinaWhereUniqueInput
    create: XOR<ProgramHotelMadinaCreateWithoutProgramInput, ProgramHotelMadinaUncheckedCreateWithoutProgramInput>
  }

  export type ProgramHotelMadinaCreateManyProgramInputEnvelope = {
    data: ProgramHotelMadinaCreateManyProgramInput | ProgramHotelMadinaCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ProgramHotelMakkahCreateWithoutProgramInput = {
    hotel: HotelCreateNestedOneWithoutProgramsMakkahInput
  }

  export type ProgramHotelMakkahUncheckedCreateWithoutProgramInput = {
    id?: number
    hotelId: number
  }

  export type ProgramHotelMakkahCreateOrConnectWithoutProgramInput = {
    where: ProgramHotelMakkahWhereUniqueInput
    create: XOR<ProgramHotelMakkahCreateWithoutProgramInput, ProgramHotelMakkahUncheckedCreateWithoutProgramInput>
  }

  export type ProgramHotelMakkahCreateManyProgramInputEnvelope = {
    data: ProgramHotelMakkahCreateManyProgramInput | ProgramHotelMakkahCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutProgramInput = {
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation?: RoomCreatelisteIdsReservationInput | number[]
    created_at?: Date | string
    updated_at?: Date | string
    hotel: HotelCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutProgramInput = {
    id?: number
    hotelId: number
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation?: RoomCreatelisteIdsReservationInput | number[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RoomCreateOrConnectWithoutProgramInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutProgramInput, RoomUncheckedCreateWithoutProgramInput>
  }

  export type RoomCreateManyProgramInputEnvelope = {
    data: RoomCreateManyProgramInput | RoomCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ReservationCreateWithoutProgramInput = {
    firstName: string
    lastName: string
    phone: string
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    documents?: FichierCreateNestedManyWithoutReservationInput
    payments?: PaymentCreateNestedManyWithoutReservationInput
    expenses?: ExpenseCreateNestedManyWithoutReservationInput
    agent?: AgentCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutProgramInput = {
    id?: number
    firstName: string
    lastName: string
    phone: string
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    agentId?: number | null
    documents?: FichierUncheckedCreateNestedManyWithoutReservationInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutProgramInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutProgramInput, ReservationUncheckedCreateWithoutProgramInput>
  }

  export type ReservationCreateManyProgramInputEnvelope = {
    data: ReservationCreateManyProgramInput | ReservationCreateManyProgramInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseUpsertWithWhereUniqueWithoutProgramInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutProgramInput, ExpenseUncheckedUpdateWithoutProgramInput>
    create: XOR<ExpenseCreateWithoutProgramInput, ExpenseUncheckedCreateWithoutProgramInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutProgramInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutProgramInput, ExpenseUncheckedUpdateWithoutProgramInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutProgramInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutProgramInput>
  }

  export type ExpenseScalarWhereInput = {
    AND?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    OR?: ExpenseScalarWhereInput[]
    NOT?: ExpenseScalarWhereInput | ExpenseScalarWhereInput[]
    id?: IntFilter<"Expense"> | number
    description?: StringFilter<"Expense"> | string
    amount?: FloatFilter<"Expense"> | number
    date?: DateTimeFilter<"Expense"> | Date | string
    type?: StringFilter<"Expense"> | string
    fichierId?: IntNullableFilter<"Expense"> | number | null
    programId?: IntNullableFilter<"Expense"> | number | null
    reservationId?: IntNullableFilter<"Expense"> | number | null
  }

  export type ProgramHotelMadinaUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramHotelMadinaWhereUniqueInput
    update: XOR<ProgramHotelMadinaUpdateWithoutProgramInput, ProgramHotelMadinaUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramHotelMadinaCreateWithoutProgramInput, ProgramHotelMadinaUncheckedCreateWithoutProgramInput>
  }

  export type ProgramHotelMadinaUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramHotelMadinaWhereUniqueInput
    data: XOR<ProgramHotelMadinaUpdateWithoutProgramInput, ProgramHotelMadinaUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramHotelMadinaUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramHotelMadinaScalarWhereInput
    data: XOR<ProgramHotelMadinaUpdateManyMutationInput, ProgramHotelMadinaUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramHotelMadinaScalarWhereInput = {
    AND?: ProgramHotelMadinaScalarWhereInput | ProgramHotelMadinaScalarWhereInput[]
    OR?: ProgramHotelMadinaScalarWhereInput[]
    NOT?: ProgramHotelMadinaScalarWhereInput | ProgramHotelMadinaScalarWhereInput[]
    id?: IntFilter<"ProgramHotelMadina"> | number
    programId?: IntFilter<"ProgramHotelMadina"> | number
    hotelId?: IntFilter<"ProgramHotelMadina"> | number
  }

  export type ProgramHotelMakkahUpsertWithWhereUniqueWithoutProgramInput = {
    where: ProgramHotelMakkahWhereUniqueInput
    update: XOR<ProgramHotelMakkahUpdateWithoutProgramInput, ProgramHotelMakkahUncheckedUpdateWithoutProgramInput>
    create: XOR<ProgramHotelMakkahCreateWithoutProgramInput, ProgramHotelMakkahUncheckedCreateWithoutProgramInput>
  }

  export type ProgramHotelMakkahUpdateWithWhereUniqueWithoutProgramInput = {
    where: ProgramHotelMakkahWhereUniqueInput
    data: XOR<ProgramHotelMakkahUpdateWithoutProgramInput, ProgramHotelMakkahUncheckedUpdateWithoutProgramInput>
  }

  export type ProgramHotelMakkahUpdateManyWithWhereWithoutProgramInput = {
    where: ProgramHotelMakkahScalarWhereInput
    data: XOR<ProgramHotelMakkahUpdateManyMutationInput, ProgramHotelMakkahUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramHotelMakkahScalarWhereInput = {
    AND?: ProgramHotelMakkahScalarWhereInput | ProgramHotelMakkahScalarWhereInput[]
    OR?: ProgramHotelMakkahScalarWhereInput[]
    NOT?: ProgramHotelMakkahScalarWhereInput | ProgramHotelMakkahScalarWhereInput[]
    id?: IntFilter<"ProgramHotelMakkah"> | number
    programId?: IntFilter<"ProgramHotelMakkah"> | number
    hotelId?: IntFilter<"ProgramHotelMakkah"> | number
  }

  export type RoomUpsertWithWhereUniqueWithoutProgramInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutProgramInput, RoomUncheckedUpdateWithoutProgramInput>
    create: XOR<RoomCreateWithoutProgramInput, RoomUncheckedCreateWithoutProgramInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutProgramInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutProgramInput, RoomUncheckedUpdateWithoutProgramInput>
  }

  export type RoomUpdateManyWithWhereWithoutProgramInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutProgramInput>
  }

  export type RoomScalarWhereInput = {
    AND?: RoomScalarWhereInput | RoomScalarWhereInput[]
    OR?: RoomScalarWhereInput[]
    NOT?: RoomScalarWhereInput | RoomScalarWhereInput[]
    id?: IntFilter<"Room"> | number
    programId?: IntFilter<"Room"> | number
    hotelId?: IntFilter<"Room"> | number
    roomType?: EnumRoomTypeFilter<"Room"> | $Enums.RoomType
    gender?: StringFilter<"Room"> | string
    nbrPlaceTotal?: IntFilter<"Room"> | number
    nbrPlaceRestantes?: IntFilter<"Room"> | number
    prixRoom?: FloatFilter<"Room"> | number
    listeIdsReservation?: IntNullableListFilter<"Room">
    created_at?: DateTimeFilter<"Room"> | Date | string
    updated_at?: DateTimeFilter<"Room"> | Date | string
  }

  export type ReservationUpsertWithWhereUniqueWithoutProgramInput = {
    where: ReservationWhereUniqueInput
    update: XOR<ReservationUpdateWithoutProgramInput, ReservationUncheckedUpdateWithoutProgramInput>
    create: XOR<ReservationCreateWithoutProgramInput, ReservationUncheckedCreateWithoutProgramInput>
  }

  export type ReservationUpdateWithWhereUniqueWithoutProgramInput = {
    where: ReservationWhereUniqueInput
    data: XOR<ReservationUpdateWithoutProgramInput, ReservationUncheckedUpdateWithoutProgramInput>
  }

  export type ReservationUpdateManyWithWhereWithoutProgramInput = {
    where: ReservationScalarWhereInput
    data: XOR<ReservationUpdateManyMutationInput, ReservationUncheckedUpdateManyWithoutProgramInput>
  }

  export type ProgramHotelMadinaCreateWithoutHotelInput = {
    program: ProgramCreateNestedOneWithoutHotelsMadinaInput
  }

  export type ProgramHotelMadinaUncheckedCreateWithoutHotelInput = {
    id?: number
    programId: number
  }

  export type ProgramHotelMadinaCreateOrConnectWithoutHotelInput = {
    where: ProgramHotelMadinaWhereUniqueInput
    create: XOR<ProgramHotelMadinaCreateWithoutHotelInput, ProgramHotelMadinaUncheckedCreateWithoutHotelInput>
  }

  export type ProgramHotelMadinaCreateManyHotelInputEnvelope = {
    data: ProgramHotelMadinaCreateManyHotelInput | ProgramHotelMadinaCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type ProgramHotelMakkahCreateWithoutHotelInput = {
    program: ProgramCreateNestedOneWithoutHotelsMakkahInput
  }

  export type ProgramHotelMakkahUncheckedCreateWithoutHotelInput = {
    id?: number
    programId: number
  }

  export type ProgramHotelMakkahCreateOrConnectWithoutHotelInput = {
    where: ProgramHotelMakkahWhereUniqueInput
    create: XOR<ProgramHotelMakkahCreateWithoutHotelInput, ProgramHotelMakkahUncheckedCreateWithoutHotelInput>
  }

  export type ProgramHotelMakkahCreateManyHotelInputEnvelope = {
    data: ProgramHotelMakkahCreateManyHotelInput | ProgramHotelMakkahCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type RoomCreateWithoutHotelInput = {
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation?: RoomCreatelisteIdsReservationInput | number[]
    created_at?: Date | string
    updated_at?: Date | string
    program: ProgramCreateNestedOneWithoutRoomsInput
  }

  export type RoomUncheckedCreateWithoutHotelInput = {
    id?: number
    programId: number
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation?: RoomCreatelisteIdsReservationInput | number[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type RoomCreateOrConnectWithoutHotelInput = {
    where: RoomWhereUniqueInput
    create: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput>
  }

  export type RoomCreateManyHotelInputEnvelope = {
    data: RoomCreateManyHotelInput | RoomCreateManyHotelInput[]
    skipDuplicates?: boolean
  }

  export type ProgramHotelMadinaUpsertWithWhereUniqueWithoutHotelInput = {
    where: ProgramHotelMadinaWhereUniqueInput
    update: XOR<ProgramHotelMadinaUpdateWithoutHotelInput, ProgramHotelMadinaUncheckedUpdateWithoutHotelInput>
    create: XOR<ProgramHotelMadinaCreateWithoutHotelInput, ProgramHotelMadinaUncheckedCreateWithoutHotelInput>
  }

  export type ProgramHotelMadinaUpdateWithWhereUniqueWithoutHotelInput = {
    where: ProgramHotelMadinaWhereUniqueInput
    data: XOR<ProgramHotelMadinaUpdateWithoutHotelInput, ProgramHotelMadinaUncheckedUpdateWithoutHotelInput>
  }

  export type ProgramHotelMadinaUpdateManyWithWhereWithoutHotelInput = {
    where: ProgramHotelMadinaScalarWhereInput
    data: XOR<ProgramHotelMadinaUpdateManyMutationInput, ProgramHotelMadinaUncheckedUpdateManyWithoutHotelInput>
  }

  export type ProgramHotelMakkahUpsertWithWhereUniqueWithoutHotelInput = {
    where: ProgramHotelMakkahWhereUniqueInput
    update: XOR<ProgramHotelMakkahUpdateWithoutHotelInput, ProgramHotelMakkahUncheckedUpdateWithoutHotelInput>
    create: XOR<ProgramHotelMakkahCreateWithoutHotelInput, ProgramHotelMakkahUncheckedCreateWithoutHotelInput>
  }

  export type ProgramHotelMakkahUpdateWithWhereUniqueWithoutHotelInput = {
    where: ProgramHotelMakkahWhereUniqueInput
    data: XOR<ProgramHotelMakkahUpdateWithoutHotelInput, ProgramHotelMakkahUncheckedUpdateWithoutHotelInput>
  }

  export type ProgramHotelMakkahUpdateManyWithWhereWithoutHotelInput = {
    where: ProgramHotelMakkahScalarWhereInput
    data: XOR<ProgramHotelMakkahUpdateManyMutationInput, ProgramHotelMakkahUncheckedUpdateManyWithoutHotelInput>
  }

  export type RoomUpsertWithWhereUniqueWithoutHotelInput = {
    where: RoomWhereUniqueInput
    update: XOR<RoomUpdateWithoutHotelInput, RoomUncheckedUpdateWithoutHotelInput>
    create: XOR<RoomCreateWithoutHotelInput, RoomUncheckedCreateWithoutHotelInput>
  }

  export type RoomUpdateWithWhereUniqueWithoutHotelInput = {
    where: RoomWhereUniqueInput
    data: XOR<RoomUpdateWithoutHotelInput, RoomUncheckedUpdateWithoutHotelInput>
  }

  export type RoomUpdateManyWithWhereWithoutHotelInput = {
    where: RoomScalarWhereInput
    data: XOR<RoomUpdateManyMutationInput, RoomUncheckedUpdateManyWithoutHotelInput>
  }

  export type ProgramCreateWithoutHotelsMadinaInput = {
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahCreateNestedManyWithoutProgramInput
    rooms?: RoomCreateNestedManyWithoutProgramInput
    reservations?: ReservationCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutHotelsMadinaInput = {
    id?: number
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseUncheckedCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedCreateNestedManyWithoutProgramInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProgramInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutHotelsMadinaInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutHotelsMadinaInput, ProgramUncheckedCreateWithoutHotelsMadinaInput>
  }

  export type HotelCreateWithoutProgramsMadinaInput = {
    name: string
    city: $Enums.City
    programsMakkah?: ProgramHotelMakkahCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutProgramsMadinaInput = {
    id?: number
    name: string
    city: $Enums.City
    programsMakkah?: ProgramHotelMakkahUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutProgramsMadinaInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutProgramsMadinaInput, HotelUncheckedCreateWithoutProgramsMadinaInput>
  }

  export type ProgramUpsertWithoutHotelsMadinaInput = {
    update: XOR<ProgramUpdateWithoutHotelsMadinaInput, ProgramUncheckedUpdateWithoutHotelsMadinaInput>
    create: XOR<ProgramCreateWithoutHotelsMadinaInput, ProgramUncheckedCreateWithoutHotelsMadinaInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutHotelsMadinaInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutHotelsMadinaInput, ProgramUncheckedUpdateWithoutHotelsMadinaInput>
  }

  export type ProgramUpdateWithoutHotelsMadinaInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUpdateManyWithoutProgramNestedInput
    rooms?: RoomUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutHotelsMadinaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUncheckedUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedUpdateManyWithoutProgramNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type HotelUpsertWithoutProgramsMadinaInput = {
    update: XOR<HotelUpdateWithoutProgramsMadinaInput, HotelUncheckedUpdateWithoutProgramsMadinaInput>
    create: XOR<HotelCreateWithoutProgramsMadinaInput, HotelUncheckedCreateWithoutProgramsMadinaInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutProgramsMadinaInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutProgramsMadinaInput, HotelUncheckedUpdateWithoutProgramsMadinaInput>
  }

  export type HotelUpdateWithoutProgramsMadinaInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
    programsMakkah?: ProgramHotelMakkahUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutProgramsMadinaInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
    programsMakkah?: ProgramHotelMakkahUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type ProgramCreateWithoutHotelsMakkahInput = {
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseCreateNestedManyWithoutProgramInput
    hotelsMadina?: ProgramHotelMadinaCreateNestedManyWithoutProgramInput
    rooms?: RoomCreateNestedManyWithoutProgramInput
    reservations?: ReservationCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutHotelsMakkahInput = {
    id?: number
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseUncheckedCreateNestedManyWithoutProgramInput
    hotelsMadina?: ProgramHotelMadinaUncheckedCreateNestedManyWithoutProgramInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProgramInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutHotelsMakkahInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutHotelsMakkahInput, ProgramUncheckedCreateWithoutHotelsMakkahInput>
  }

  export type HotelCreateWithoutProgramsMakkahInput = {
    name: string
    city: $Enums.City
    programsMadina?: ProgramHotelMadinaCreateNestedManyWithoutHotelInput
    rooms?: RoomCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutProgramsMakkahInput = {
    id?: number
    name: string
    city: $Enums.City
    programsMadina?: ProgramHotelMadinaUncheckedCreateNestedManyWithoutHotelInput
    rooms?: RoomUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutProgramsMakkahInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutProgramsMakkahInput, HotelUncheckedCreateWithoutProgramsMakkahInput>
  }

  export type ProgramUpsertWithoutHotelsMakkahInput = {
    update: XOR<ProgramUpdateWithoutHotelsMakkahInput, ProgramUncheckedUpdateWithoutHotelsMakkahInput>
    create: XOR<ProgramCreateWithoutHotelsMakkahInput, ProgramUncheckedCreateWithoutHotelsMakkahInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutHotelsMakkahInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutHotelsMakkahInput, ProgramUncheckedUpdateWithoutHotelsMakkahInput>
  }

  export type ProgramUpdateWithoutHotelsMakkahInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUpdateManyWithoutProgramNestedInput
    hotelsMadina?: ProgramHotelMadinaUpdateManyWithoutProgramNestedInput
    rooms?: RoomUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutHotelsMakkahInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUncheckedUpdateManyWithoutProgramNestedInput
    hotelsMadina?: ProgramHotelMadinaUncheckedUpdateManyWithoutProgramNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type HotelUpsertWithoutProgramsMakkahInput = {
    update: XOR<HotelUpdateWithoutProgramsMakkahInput, HotelUncheckedUpdateWithoutProgramsMakkahInput>
    create: XOR<HotelCreateWithoutProgramsMakkahInput, HotelUncheckedCreateWithoutProgramsMakkahInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutProgramsMakkahInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutProgramsMakkahInput, HotelUncheckedUpdateWithoutProgramsMakkahInput>
  }

  export type HotelUpdateWithoutProgramsMakkahInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
    programsMadina?: ProgramHotelMadinaUpdateManyWithoutHotelNestedInput
    rooms?: RoomUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutProgramsMakkahInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
    programsMadina?: ProgramHotelMadinaUncheckedUpdateManyWithoutHotelNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type ProgramCreateWithoutRoomsInput = {
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseCreateNestedManyWithoutProgramInput
    hotelsMadina?: ProgramHotelMadinaCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahCreateNestedManyWithoutProgramInput
    reservations?: ReservationCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutRoomsInput = {
    id?: number
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseUncheckedCreateNestedManyWithoutProgramInput
    hotelsMadina?: ProgramHotelMadinaUncheckedCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedCreateNestedManyWithoutProgramInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutRoomsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutRoomsInput, ProgramUncheckedCreateWithoutRoomsInput>
  }

  export type HotelCreateWithoutRoomsInput = {
    name: string
    city: $Enums.City
    programsMadina?: ProgramHotelMadinaCreateNestedManyWithoutHotelInput
    programsMakkah?: ProgramHotelMakkahCreateNestedManyWithoutHotelInput
  }

  export type HotelUncheckedCreateWithoutRoomsInput = {
    id?: number
    name: string
    city: $Enums.City
    programsMadina?: ProgramHotelMadinaUncheckedCreateNestedManyWithoutHotelInput
    programsMakkah?: ProgramHotelMakkahUncheckedCreateNestedManyWithoutHotelInput
  }

  export type HotelCreateOrConnectWithoutRoomsInput = {
    where: HotelWhereUniqueInput
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
  }

  export type ProgramUpsertWithoutRoomsInput = {
    update: XOR<ProgramUpdateWithoutRoomsInput, ProgramUncheckedUpdateWithoutRoomsInput>
    create: XOR<ProgramCreateWithoutRoomsInput, ProgramUncheckedCreateWithoutRoomsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutRoomsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutRoomsInput, ProgramUncheckedUpdateWithoutRoomsInput>
  }

  export type ProgramUpdateWithoutRoomsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUpdateManyWithoutProgramNestedInput
    hotelsMadina?: ProgramHotelMadinaUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUncheckedUpdateManyWithoutProgramNestedInput
    hotelsMadina?: ProgramHotelMadinaUncheckedUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type HotelUpsertWithoutRoomsInput = {
    update: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
    create: XOR<HotelCreateWithoutRoomsInput, HotelUncheckedCreateWithoutRoomsInput>
    where?: HotelWhereInput
  }

  export type HotelUpdateToOneWithWhereWithoutRoomsInput = {
    where?: HotelWhereInput
    data: XOR<HotelUpdateWithoutRoomsInput, HotelUncheckedUpdateWithoutRoomsInput>
  }

  export type HotelUpdateWithoutRoomsInput = {
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
    programsMadina?: ProgramHotelMadinaUpdateManyWithoutHotelNestedInput
    programsMakkah?: ProgramHotelMakkahUpdateManyWithoutHotelNestedInput
  }

  export type HotelUncheckedUpdateWithoutRoomsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    city?: EnumCityFieldUpdateOperationsInput | $Enums.City
    programsMadina?: ProgramHotelMadinaUncheckedUpdateManyWithoutHotelNestedInput
    programsMakkah?: ProgramHotelMakkahUncheckedUpdateManyWithoutHotelNestedInput
  }

  export type FichierCreateWithoutReservationInput = {
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
    payment?: PaymentCreateNestedOneWithoutFichierInput
    expenses?: ExpenseCreateNestedManyWithoutFichierInput
  }

  export type FichierUncheckedCreateWithoutReservationInput = {
    id?: number
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutFichierInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFichierInput
  }

  export type FichierCreateOrConnectWithoutReservationInput = {
    where: FichierWhereUniqueInput
    create: XOR<FichierCreateWithoutReservationInput, FichierUncheckedCreateWithoutReservationInput>
  }

  export type FichierCreateManyReservationInputEnvelope = {
    data: FichierCreateManyReservationInput | FichierCreateManyReservationInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutReservationInput = {
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    programId?: number | null
    fichier?: FichierCreateNestedOneWithoutPaymentInput
    agent?: AgentCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutReservationInput = {
    id?: number
    agentId?: number | null
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    fichierId?: number | null
    programId?: number | null
  }

  export type PaymentCreateOrConnectWithoutReservationInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutReservationInput, PaymentUncheckedCreateWithoutReservationInput>
  }

  export type PaymentCreateManyReservationInputEnvelope = {
    data: PaymentCreateManyReservationInput | PaymentCreateManyReservationInput[]
    skipDuplicates?: boolean
  }

  export type ExpenseCreateWithoutReservationInput = {
    description: string
    amount: number
    date?: Date | string
    type: string
    program?: ProgramCreateNestedOneWithoutExpensesInput
    fichier?: FichierCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutReservationInput = {
    id?: number
    description: string
    amount: number
    date?: Date | string
    type: string
    fichierId?: number | null
    programId?: number | null
  }

  export type ExpenseCreateOrConnectWithoutReservationInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutReservationInput, ExpenseUncheckedCreateWithoutReservationInput>
  }

  export type ExpenseCreateManyReservationInputEnvelope = {
    data: ExpenseCreateManyReservationInput | ExpenseCreateManyReservationInput[]
    skipDuplicates?: boolean
  }

  export type ProgramCreateWithoutReservationsInput = {
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseCreateNestedManyWithoutProgramInput
    hotelsMadina?: ProgramHotelMadinaCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahCreateNestedManyWithoutProgramInput
    rooms?: RoomCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutReservationsInput = {
    id?: number
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    expenses?: ExpenseUncheckedCreateNestedManyWithoutProgramInput
    hotelsMadina?: ProgramHotelMadinaUncheckedCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedCreateNestedManyWithoutProgramInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutReservationsInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutReservationsInput, ProgramUncheckedCreateWithoutReservationsInput>
  }

  export type AgentCreateWithoutReservationsInput = {
    nom: string
    email?: string | null
    motDePasse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutReservationsInput = {
    id?: number
    nom: string
    email?: string | null
    motDePasse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutReservationsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutReservationsInput, AgentUncheckedCreateWithoutReservationsInput>
  }

  export type FichierUpsertWithWhereUniqueWithoutReservationInput = {
    where: FichierWhereUniqueInput
    update: XOR<FichierUpdateWithoutReservationInput, FichierUncheckedUpdateWithoutReservationInput>
    create: XOR<FichierCreateWithoutReservationInput, FichierUncheckedCreateWithoutReservationInput>
  }

  export type FichierUpdateWithWhereUniqueWithoutReservationInput = {
    where: FichierWhereUniqueInput
    data: XOR<FichierUpdateWithoutReservationInput, FichierUncheckedUpdateWithoutReservationInput>
  }

  export type FichierUpdateManyWithWhereWithoutReservationInput = {
    where: FichierScalarWhereInput
    data: XOR<FichierUpdateManyMutationInput, FichierUncheckedUpdateManyWithoutReservationInput>
  }

  export type FichierScalarWhereInput = {
    AND?: FichierScalarWhereInput | FichierScalarWhereInput[]
    OR?: FichierScalarWhereInput[]
    NOT?: FichierScalarWhereInput | FichierScalarWhereInput[]
    id?: IntFilter<"Fichier"> | number
    reservationId?: IntFilter<"Fichier"> | number
    fileName?: StringFilter<"Fichier"> | string
    storedName?: StringFilter<"Fichier"> | string
    fileType?: StringFilter<"Fichier"> | string
    fileCategory?: StringFilter<"Fichier"> | string
    filePath?: StringFilter<"Fichier"> | string
    uploaded_at?: DateTimeFilter<"Fichier"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutReservationInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutReservationInput, PaymentUncheckedUpdateWithoutReservationInput>
    create: XOR<PaymentCreateWithoutReservationInput, PaymentUncheckedCreateWithoutReservationInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutReservationInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutReservationInput, PaymentUncheckedUpdateWithoutReservationInput>
  }

  export type PaymentUpdateManyWithWhereWithoutReservationInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutReservationInput>
  }

  export type ExpenseUpsertWithWhereUniqueWithoutReservationInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutReservationInput, ExpenseUncheckedUpdateWithoutReservationInput>
    create: XOR<ExpenseCreateWithoutReservationInput, ExpenseUncheckedCreateWithoutReservationInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutReservationInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutReservationInput, ExpenseUncheckedUpdateWithoutReservationInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutReservationInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutReservationInput>
  }

  export type ProgramUpsertWithoutReservationsInput = {
    update: XOR<ProgramUpdateWithoutReservationsInput, ProgramUncheckedUpdateWithoutReservationsInput>
    create: XOR<ProgramCreateWithoutReservationsInput, ProgramUncheckedCreateWithoutReservationsInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutReservationsInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutReservationsInput, ProgramUncheckedUpdateWithoutReservationsInput>
  }

  export type ProgramUpdateWithoutReservationsInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUpdateManyWithoutProgramNestedInput
    hotelsMadina?: ProgramHotelMadinaUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUpdateManyWithoutProgramNestedInput
    rooms?: RoomUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    expenses?: ExpenseUncheckedUpdateManyWithoutProgramNestedInput
    hotelsMadina?: ProgramHotelMadinaUncheckedUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedUpdateManyWithoutProgramNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type AgentUpsertWithoutReservationsInput = {
    update: XOR<AgentUpdateWithoutReservationsInput, AgentUncheckedUpdateWithoutReservationsInput>
    create: XOR<AgentCreateWithoutReservationsInput, AgentUncheckedCreateWithoutReservationsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutReservationsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutReservationsInput, AgentUncheckedUpdateWithoutReservationsInput>
  }

  export type AgentUpdateWithoutReservationsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    motDePasse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutReservationsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    motDePasse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ReservationCreateWithoutDocumentsInput = {
    firstName: string
    lastName: string
    phone: string
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    payments?: PaymentCreateNestedManyWithoutReservationInput
    expenses?: ExpenseCreateNestedManyWithoutReservationInput
    program: ProgramCreateNestedOneWithoutReservationsInput
    agent?: AgentCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutDocumentsInput = {
    id?: number
    firstName: string
    lastName: string
    phone: string
    programId: number
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    agentId?: number | null
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutDocumentsInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutDocumentsInput, ReservationUncheckedCreateWithoutDocumentsInput>
  }

  export type PaymentCreateWithoutFichierInput = {
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    programId?: number | null
    reservation: ReservationCreateNestedOneWithoutPaymentsInput
    agent?: AgentCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutFichierInput = {
    id?: number
    reservationId: number
    agentId?: number | null
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    programId?: number | null
  }

  export type PaymentCreateOrConnectWithoutFichierInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutFichierInput, PaymentUncheckedCreateWithoutFichierInput>
  }

  export type ExpenseCreateWithoutFichierInput = {
    description: string
    amount: number
    date?: Date | string
    type: string
    program?: ProgramCreateNestedOneWithoutExpensesInput
    reservation?: ReservationCreateNestedOneWithoutExpensesInput
  }

  export type ExpenseUncheckedCreateWithoutFichierInput = {
    id?: number
    description: string
    amount: number
    date?: Date | string
    type: string
    programId?: number | null
    reservationId?: number | null
  }

  export type ExpenseCreateOrConnectWithoutFichierInput = {
    where: ExpenseWhereUniqueInput
    create: XOR<ExpenseCreateWithoutFichierInput, ExpenseUncheckedCreateWithoutFichierInput>
  }

  export type ExpenseCreateManyFichierInputEnvelope = {
    data: ExpenseCreateManyFichierInput | ExpenseCreateManyFichierInput[]
    skipDuplicates?: boolean
  }

  export type ReservationUpsertWithoutDocumentsInput = {
    update: XOR<ReservationUpdateWithoutDocumentsInput, ReservationUncheckedUpdateWithoutDocumentsInput>
    create: XOR<ReservationCreateWithoutDocumentsInput, ReservationUncheckedCreateWithoutDocumentsInput>
    where?: ReservationWhereInput
  }

  export type ReservationUpdateToOneWithWhereWithoutDocumentsInput = {
    where?: ReservationWhereInput
    data: XOR<ReservationUpdateWithoutDocumentsInput, ReservationUncheckedUpdateWithoutDocumentsInput>
  }

  export type ReservationUpdateWithoutDocumentsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUpdateManyWithoutReservationNestedInput
    program?: ProgramUpdateOneRequiredWithoutReservationsNestedInput
    agent?: AgentUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutDocumentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type PaymentUpsertWithoutFichierInput = {
    update: XOR<PaymentUpdateWithoutFichierInput, PaymentUncheckedUpdateWithoutFichierInput>
    create: XOR<PaymentCreateWithoutFichierInput, PaymentUncheckedCreateWithoutFichierInput>
    where?: PaymentWhereInput
  }

  export type PaymentUpdateToOneWithWhereWithoutFichierInput = {
    where?: PaymentWhereInput
    data: XOR<PaymentUpdateWithoutFichierInput, PaymentUncheckedUpdateWithoutFichierInput>
  }

  export type PaymentUpdateWithoutFichierInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    reservation?: ReservationUpdateOneRequiredWithoutPaymentsNestedInput
    agent?: AgentUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutFichierInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservationId?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseUpsertWithWhereUniqueWithoutFichierInput = {
    where: ExpenseWhereUniqueInput
    update: XOR<ExpenseUpdateWithoutFichierInput, ExpenseUncheckedUpdateWithoutFichierInput>
    create: XOR<ExpenseCreateWithoutFichierInput, ExpenseUncheckedCreateWithoutFichierInput>
  }

  export type ExpenseUpdateWithWhereUniqueWithoutFichierInput = {
    where: ExpenseWhereUniqueInput
    data: XOR<ExpenseUpdateWithoutFichierInput, ExpenseUncheckedUpdateWithoutFichierInput>
  }

  export type ExpenseUpdateManyWithWhereWithoutFichierInput = {
    where: ExpenseScalarWhereInput
    data: XOR<ExpenseUpdateManyMutationInput, ExpenseUncheckedUpdateManyWithoutFichierInput>
  }

  export type FichierCreateWithoutPaymentInput = {
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
    reservation: ReservationCreateNestedOneWithoutDocumentsInput
    expenses?: ExpenseCreateNestedManyWithoutFichierInput
  }

  export type FichierUncheckedCreateWithoutPaymentInput = {
    id?: number
    reservationId: number
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
    expenses?: ExpenseUncheckedCreateNestedManyWithoutFichierInput
  }

  export type FichierCreateOrConnectWithoutPaymentInput = {
    where: FichierWhereUniqueInput
    create: XOR<FichierCreateWithoutPaymentInput, FichierUncheckedCreateWithoutPaymentInput>
  }

  export type ReservationCreateWithoutPaymentsInput = {
    firstName: string
    lastName: string
    phone: string
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    documents?: FichierCreateNestedManyWithoutReservationInput
    expenses?: ExpenseCreateNestedManyWithoutReservationInput
    program: ProgramCreateNestedOneWithoutReservationsInput
    agent?: AgentCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutPaymentsInput = {
    id?: number
    firstName: string
    lastName: string
    phone: string
    programId: number
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    agentId?: number | null
    documents?: FichierUncheckedCreateNestedManyWithoutReservationInput
    expenses?: ExpenseUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutPaymentsInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutPaymentsInput, ReservationUncheckedCreateWithoutPaymentsInput>
  }

  export type AgentCreateWithoutPaymentsInput = {
    nom: string
    email?: string | null
    motDePasse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationCreateNestedManyWithoutAgentInput
  }

  export type AgentUncheckedCreateWithoutPaymentsInput = {
    id?: number
    nom: string
    email?: string | null
    motDePasse: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    reservations?: ReservationUncheckedCreateNestedManyWithoutAgentInput
  }

  export type AgentCreateOrConnectWithoutPaymentsInput = {
    where: AgentWhereUniqueInput
    create: XOR<AgentCreateWithoutPaymentsInput, AgentUncheckedCreateWithoutPaymentsInput>
  }

  export type FichierUpsertWithoutPaymentInput = {
    update: XOR<FichierUpdateWithoutPaymentInput, FichierUncheckedUpdateWithoutPaymentInput>
    create: XOR<FichierCreateWithoutPaymentInput, FichierUncheckedCreateWithoutPaymentInput>
    where?: FichierWhereInput
  }

  export type FichierUpdateToOneWithWhereWithoutPaymentInput = {
    where?: FichierWhereInput
    data: XOR<FichierUpdateWithoutPaymentInput, FichierUncheckedUpdateWithoutPaymentInput>
  }

  export type FichierUpdateWithoutPaymentInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reservation?: ReservationUpdateOneRequiredWithoutDocumentsNestedInput
    expenses?: ExpenseUpdateManyWithoutFichierNestedInput
  }

  export type FichierUncheckedUpdateWithoutPaymentInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservationId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    expenses?: ExpenseUncheckedUpdateManyWithoutFichierNestedInput
  }

  export type ReservationUpsertWithoutPaymentsInput = {
    update: XOR<ReservationUpdateWithoutPaymentsInput, ReservationUncheckedUpdateWithoutPaymentsInput>
    create: XOR<ReservationCreateWithoutPaymentsInput, ReservationUncheckedCreateWithoutPaymentsInput>
    where?: ReservationWhereInput
  }

  export type ReservationUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: ReservationWhereInput
    data: XOR<ReservationUpdateWithoutPaymentsInput, ReservationUncheckedUpdateWithoutPaymentsInput>
  }

  export type ReservationUpdateWithoutPaymentsInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FichierUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUpdateManyWithoutReservationNestedInput
    program?: ProgramUpdateOneRequiredWithoutReservationsNestedInput
    agent?: AgentUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    documents?: FichierUncheckedUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type AgentUpsertWithoutPaymentsInput = {
    update: XOR<AgentUpdateWithoutPaymentsInput, AgentUncheckedUpdateWithoutPaymentsInput>
    create: XOR<AgentCreateWithoutPaymentsInput, AgentUncheckedCreateWithoutPaymentsInput>
    where?: AgentWhereInput
  }

  export type AgentUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: AgentWhereInput
    data: XOR<AgentUpdateWithoutPaymentsInput, AgentUncheckedUpdateWithoutPaymentsInput>
  }

  export type AgentUpdateWithoutPaymentsInput = {
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    motDePasse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUpdateManyWithoutAgentNestedInput
  }

  export type AgentUncheckedUpdateWithoutPaymentsInput = {
    id?: IntFieldUpdateOperationsInput | number
    nom?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    motDePasse?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reservations?: ReservationUncheckedUpdateManyWithoutAgentNestedInput
  }

  export type ProgramCreateWithoutExpensesInput = {
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    hotelsMadina?: ProgramHotelMadinaCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahCreateNestedManyWithoutProgramInput
    rooms?: RoomCreateNestedManyWithoutProgramInput
    reservations?: ReservationCreateNestedManyWithoutProgramInput
  }

  export type ProgramUncheckedCreateWithoutExpensesInput = {
    id?: number
    name: string
    created_at?: Date | string
    visaDeadline?: Date | string | null
    hotelDeadline?: Date | string | null
    flightDeadline?: Date | string | null
    passportDeadline?: Date | string | null
    nbJoursMadina?: number
    nbJoursMakkah?: number
    exchange?: number
    prixAvionDH?: number
    prixVisaRiyal?: number
    profit?: number
    hotelsMadina?: ProgramHotelMadinaUncheckedCreateNestedManyWithoutProgramInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedCreateNestedManyWithoutProgramInput
    rooms?: RoomUncheckedCreateNestedManyWithoutProgramInput
    reservations?: ReservationUncheckedCreateNestedManyWithoutProgramInput
  }

  export type ProgramCreateOrConnectWithoutExpensesInput = {
    where: ProgramWhereUniqueInput
    create: XOR<ProgramCreateWithoutExpensesInput, ProgramUncheckedCreateWithoutExpensesInput>
  }

  export type ReservationCreateWithoutExpensesInput = {
    firstName: string
    lastName: string
    phone: string
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    documents?: FichierCreateNestedManyWithoutReservationInput
    payments?: PaymentCreateNestedManyWithoutReservationInput
    program: ProgramCreateNestedOneWithoutReservationsInput
    agent?: AgentCreateNestedOneWithoutReservationsInput
  }

  export type ReservationUncheckedCreateWithoutExpensesInput = {
    id?: number
    firstName: string
    lastName: string
    phone: string
    programId: number
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    agentId?: number | null
    documents?: FichierUncheckedCreateNestedManyWithoutReservationInput
    payments?: PaymentUncheckedCreateNestedManyWithoutReservationInput
  }

  export type ReservationCreateOrConnectWithoutExpensesInput = {
    where: ReservationWhereUniqueInput
    create: XOR<ReservationCreateWithoutExpensesInput, ReservationUncheckedCreateWithoutExpensesInput>
  }

  export type FichierCreateWithoutExpensesInput = {
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
    reservation: ReservationCreateNestedOneWithoutDocumentsInput
    payment?: PaymentCreateNestedOneWithoutFichierInput
  }

  export type FichierUncheckedCreateWithoutExpensesInput = {
    id?: number
    reservationId: number
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
    payment?: PaymentUncheckedCreateNestedOneWithoutFichierInput
  }

  export type FichierCreateOrConnectWithoutExpensesInput = {
    where: FichierWhereUniqueInput
    create: XOR<FichierCreateWithoutExpensesInput, FichierUncheckedCreateWithoutExpensesInput>
  }

  export type ProgramUpsertWithoutExpensesInput = {
    update: XOR<ProgramUpdateWithoutExpensesInput, ProgramUncheckedUpdateWithoutExpensesInput>
    create: XOR<ProgramCreateWithoutExpensesInput, ProgramUncheckedCreateWithoutExpensesInput>
    where?: ProgramWhereInput
  }

  export type ProgramUpdateToOneWithWhereWithoutExpensesInput = {
    where?: ProgramWhereInput
    data: XOR<ProgramUpdateWithoutExpensesInput, ProgramUncheckedUpdateWithoutExpensesInput>
  }

  export type ProgramUpdateWithoutExpensesInput = {
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    hotelsMadina?: ProgramHotelMadinaUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUpdateManyWithoutProgramNestedInput
    rooms?: RoomUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUpdateManyWithoutProgramNestedInput
  }

  export type ProgramUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    name?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    visaDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    hotelDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    flightDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    passportDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    nbJoursMadina?: IntFieldUpdateOperationsInput | number
    nbJoursMakkah?: IntFieldUpdateOperationsInput | number
    exchange?: FloatFieldUpdateOperationsInput | number
    prixAvionDH?: FloatFieldUpdateOperationsInput | number
    prixVisaRiyal?: FloatFieldUpdateOperationsInput | number
    profit?: FloatFieldUpdateOperationsInput | number
    hotelsMadina?: ProgramHotelMadinaUncheckedUpdateManyWithoutProgramNestedInput
    hotelsMakkah?: ProgramHotelMakkahUncheckedUpdateManyWithoutProgramNestedInput
    rooms?: RoomUncheckedUpdateManyWithoutProgramNestedInput
    reservations?: ReservationUncheckedUpdateManyWithoutProgramNestedInput
  }

  export type ReservationUpsertWithoutExpensesInput = {
    update: XOR<ReservationUpdateWithoutExpensesInput, ReservationUncheckedUpdateWithoutExpensesInput>
    create: XOR<ReservationCreateWithoutExpensesInput, ReservationUncheckedCreateWithoutExpensesInput>
    where?: ReservationWhereInput
  }

  export type ReservationUpdateToOneWithWhereWithoutExpensesInput = {
    where?: ReservationWhereInput
    data: XOR<ReservationUpdateWithoutExpensesInput, ReservationUncheckedUpdateWithoutExpensesInput>
  }

  export type ReservationUpdateWithoutExpensesInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FichierUpdateManyWithoutReservationNestedInput
    payments?: PaymentUpdateManyWithoutReservationNestedInput
    program?: ProgramUpdateOneRequiredWithoutReservationsNestedInput
    agent?: AgentUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    documents?: FichierUncheckedUpdateManyWithoutReservationNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type FichierUpsertWithoutExpensesInput = {
    update: XOR<FichierUpdateWithoutExpensesInput, FichierUncheckedUpdateWithoutExpensesInput>
    create: XOR<FichierCreateWithoutExpensesInput, FichierUncheckedCreateWithoutExpensesInput>
    where?: FichierWhereInput
  }

  export type FichierUpdateToOneWithWhereWithoutExpensesInput = {
    where?: FichierWhereInput
    data: XOR<FichierUpdateWithoutExpensesInput, FichierUncheckedUpdateWithoutExpensesInput>
  }

  export type FichierUpdateWithoutExpensesInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    reservation?: ReservationUpdateOneRequiredWithoutDocumentsNestedInput
    payment?: PaymentUpdateOneWithoutFichierNestedInput
  }

  export type FichierUncheckedUpdateWithoutExpensesInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservationId?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutFichierNestedInput
  }

  export type ReservationCreateManyAgentInput = {
    id?: number
    firstName: string
    lastName: string
    phone: string
    programId: number
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PaymentCreateManyAgentInput = {
    id?: number
    reservationId: number
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    fichierId?: number | null
    programId?: number | null
  }

  export type ReservationUpdateWithoutAgentInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FichierUpdateManyWithoutReservationNestedInput
    payments?: PaymentUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUpdateManyWithoutReservationNestedInput
    program?: ProgramUpdateOneRequiredWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FichierUncheckedUpdateManyWithoutReservationNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    programId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutAgentInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    fichier?: FichierUpdateOneWithoutPaymentNestedInput
    reservation?: ReservationUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservationId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentUncheckedUpdateManyWithoutAgentInput = {
    id?: IntFieldUpdateOperationsInput | number
    reservationId?: IntFieldUpdateOperationsInput | number
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseCreateManyProgramInput = {
    id?: number
    description: string
    amount: number
    date?: Date | string
    type: string
    fichierId?: number | null
    reservationId?: number | null
  }

  export type ProgramHotelMadinaCreateManyProgramInput = {
    id?: number
    hotelId: number
  }

  export type ProgramHotelMakkahCreateManyProgramInput = {
    id?: number
    hotelId: number
  }

  export type RoomCreateManyProgramInput = {
    id?: number
    hotelId: number
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation?: RoomCreatelisteIdsReservationInput | number[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ReservationCreateManyProgramInput = {
    id?: number
    firstName: string
    lastName: string
    phone: string
    roomType: $Enums.RoomType
    gender?: string
    hotelMadina?: string | null
    hotelMakkah?: string | null
    price: number
    reduction?: number
    paidAmount?: number
    status?: string
    statutPasseport?: boolean
    statutVisa?: boolean
    statutHotel?: boolean
    statutVol?: boolean
    reservationDate: Date | string
    created_at?: Date | string
    updated_at?: Date | string
    agentId?: number | null
  }

  export type ExpenseUpdateWithoutProgramInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    reservation?: ReservationUpdateOneWithoutExpensesNestedInput
    fichier?: FichierUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    reservationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    reservationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramHotelMadinaUpdateWithoutProgramInput = {
    hotel?: HotelUpdateOneRequiredWithoutProgramsMadinaNestedInput
  }

  export type ProgramHotelMadinaUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramHotelMadinaUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramHotelMakkahUpdateWithoutProgramInput = {
    hotel?: HotelUpdateOneRequiredWithoutProgramsMakkahNestedInput
  }

  export type ProgramHotelMakkahUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramHotelMakkahUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomUpdateWithoutProgramInput = {
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    hotel?: HotelUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    hotelId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ReservationUpdateWithoutProgramInput = {
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    documents?: FichierUpdateManyWithoutReservationNestedInput
    payments?: PaymentUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUpdateManyWithoutReservationNestedInput
    agent?: AgentUpdateOneWithoutReservationsNestedInput
  }

  export type ReservationUncheckedUpdateWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    documents?: FichierUncheckedUpdateManyWithoutReservationNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutReservationNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutReservationNestedInput
  }

  export type ReservationUncheckedUpdateManyWithoutProgramInput = {
    id?: IntFieldUpdateOperationsInput | number
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    phone?: StringFieldUpdateOperationsInput | string
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    hotelMadina?: NullableStringFieldUpdateOperationsInput | string | null
    hotelMakkah?: NullableStringFieldUpdateOperationsInput | string | null
    price?: FloatFieldUpdateOperationsInput | number
    reduction?: FloatFieldUpdateOperationsInput | number
    paidAmount?: FloatFieldUpdateOperationsInput | number
    status?: StringFieldUpdateOperationsInput | string
    statutPasseport?: BoolFieldUpdateOperationsInput | boolean
    statutVisa?: BoolFieldUpdateOperationsInput | boolean
    statutHotel?: BoolFieldUpdateOperationsInput | boolean
    statutVol?: BoolFieldUpdateOperationsInput | boolean
    reservationDate?: DateTimeFieldUpdateOperationsInput | Date | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ProgramHotelMadinaCreateManyHotelInput = {
    id?: number
    programId: number
  }

  export type ProgramHotelMakkahCreateManyHotelInput = {
    id?: number
    programId: number
  }

  export type RoomCreateManyHotelInput = {
    id?: number
    programId: number
    roomType: $Enums.RoomType
    gender: string
    nbrPlaceTotal: number
    nbrPlaceRestantes: number
    prixRoom: number
    listeIdsReservation?: RoomCreatelisteIdsReservationInput | number[]
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProgramHotelMadinaUpdateWithoutHotelInput = {
    program?: ProgramUpdateOneRequiredWithoutHotelsMadinaNestedInput
  }

  export type ProgramHotelMadinaUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramHotelMadinaUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramHotelMakkahUpdateWithoutHotelInput = {
    program?: ProgramUpdateOneRequiredWithoutHotelsMakkahNestedInput
  }

  export type ProgramHotelMakkahUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
  }

  export type ProgramHotelMakkahUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
  }

  export type RoomUpdateWithoutHotelInput = {
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    program?: ProgramUpdateOneRequiredWithoutRoomsNestedInput
  }

  export type RoomUncheckedUpdateWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoomUncheckedUpdateManyWithoutHotelInput = {
    id?: IntFieldUpdateOperationsInput | number
    programId?: IntFieldUpdateOperationsInput | number
    roomType?: EnumRoomTypeFieldUpdateOperationsInput | $Enums.RoomType
    gender?: StringFieldUpdateOperationsInput | string
    nbrPlaceTotal?: IntFieldUpdateOperationsInput | number
    nbrPlaceRestantes?: IntFieldUpdateOperationsInput | number
    prixRoom?: FloatFieldUpdateOperationsInput | number
    listeIdsReservation?: RoomUpdatelisteIdsReservationInput | number[]
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FichierCreateManyReservationInput = {
    id?: number
    fileName: string
    storedName: string
    fileType: string
    fileCategory: string
    filePath: string
    uploaded_at?: Date | string
  }

  export type PaymentCreateManyReservationInput = {
    id?: number
    agentId?: number | null
    amount: number
    paymentMethod: string
    paymentDate?: Date | string
    fichierId?: number | null
    programId?: number | null
  }

  export type ExpenseCreateManyReservationInput = {
    id?: number
    description: string
    amount: number
    date?: Date | string
    type: string
    fichierId?: number | null
    programId?: number | null
  }

  export type FichierUpdateWithoutReservationInput = {
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUpdateOneWithoutFichierNestedInput
    expenses?: ExpenseUpdateManyWithoutFichierNestedInput
  }

  export type FichierUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payment?: PaymentUncheckedUpdateOneWithoutFichierNestedInput
    expenses?: ExpenseUncheckedUpdateManyWithoutFichierNestedInput
  }

  export type FichierUncheckedUpdateManyWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    fileName?: StringFieldUpdateOperationsInput | string
    storedName?: StringFieldUpdateOperationsInput | string
    fileType?: StringFieldUpdateOperationsInput | string
    fileCategory?: StringFieldUpdateOperationsInput | string
    filePath?: StringFieldUpdateOperationsInput | string
    uploaded_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutReservationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    fichier?: FichierUpdateOneWithoutPaymentNestedInput
    agent?: AgentUpdateOneWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type PaymentUncheckedUpdateManyWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    agentId?: NullableIntFieldUpdateOperationsInput | number | null
    amount?: FloatFieldUpdateOperationsInput | number
    paymentMethod?: StringFieldUpdateOperationsInput | string
    paymentDate?: DateTimeFieldUpdateOperationsInput | Date | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseUpdateWithoutReservationInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    program?: ProgramUpdateOneWithoutExpensesNestedInput
    fichier?: FichierUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseUncheckedUpdateManyWithoutReservationInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    fichierId?: NullableIntFieldUpdateOperationsInput | number | null
    programId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseCreateManyFichierInput = {
    id?: number
    description: string
    amount: number
    date?: Date | string
    type: string
    programId?: number | null
    reservationId?: number | null
  }

  export type ExpenseUpdateWithoutFichierInput = {
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    program?: ProgramUpdateOneWithoutExpensesNestedInput
    reservation?: ReservationUpdateOneWithoutExpensesNestedInput
  }

  export type ExpenseUncheckedUpdateWithoutFichierInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    reservationId?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type ExpenseUncheckedUpdateManyWithoutFichierInput = {
    id?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: StringFieldUpdateOperationsInput | string
    programId?: NullableIntFieldUpdateOperationsInput | number | null
    reservationId?: NullableIntFieldUpdateOperationsInput | number | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use AgentCountOutputTypeDefaultArgs instead
     */
    export type AgentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramCountOutputTypeDefaultArgs instead
     */
    export type ProgramCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelCountOutputTypeDefaultArgs instead
     */
    export type HotelCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservationCountOutputTypeDefaultArgs instead
     */
    export type ReservationCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservationCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FichierCountOutputTypeDefaultArgs instead
     */
    export type FichierCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FichierCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AgentDefaultArgs instead
     */
    export type AgentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AgentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramDefaultArgs instead
     */
    export type ProgramArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HotelDefaultArgs instead
     */
    export type HotelArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HotelDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramHotelMadinaDefaultArgs instead
     */
    export type ProgramHotelMadinaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramHotelMadinaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProgramHotelMakkahDefaultArgs instead
     */
    export type ProgramHotelMakkahArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProgramHotelMakkahDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoomDefaultArgs instead
     */
    export type RoomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoomDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ReservationDefaultArgs instead
     */
    export type ReservationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ReservationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use FichierDefaultArgs instead
     */
    export type FichierArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = FichierDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PaymentDefaultArgs instead
     */
    export type PaymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PaymentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ExpenseDefaultArgs instead
     */
    export type ExpenseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ExpenseDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}